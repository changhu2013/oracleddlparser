/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 
 * which accompanies this distribution. 
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
options {
    MULTI = false;
    STATIC = true;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
    VISITOR = true;
    NODE_CLASS = "PLSQLNode";
    NODE_USES_PARSER = false;
    SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
    /*
    TRACK_TOKENS = true;
    DEBUG_PARSER = true;
	*/
}
PARSER_BEGIN(PLSQLParser)
/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 
 * which accompanies this distribution. 
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
package org.eclipse.persistence.tools.dbws.plsqlparser;

public class PLSQLParser {

    public PLSQLParser() {
      super();
    }
    
    public static void main( String args[] ) throws ParseException {
        PLSQLParser p = null ;
        if (args.length < 1) {
            System.out.println("Reading from stdin") ;
            p = new PLSQLParser(System.in) ;
        }
        else {
            try {
                p = new PLSQLParser(new java.io.DataInputStream(
                                new java.io.FileInputStream(args[0]))) ;
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new PLSQLParser(System.in) ;
            }
        }
        SimpleNode sn = p.parsePLSQLPackage();
        sn.dump(">");
    }
}

PARSER_END(PLSQLParser)

// white-space
SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

// comments
SKIP: {
    <COMMENT_LINE: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:{
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// PLSQL keywords (NB: may not be a complete list)
TOKEN: {
    <K_A: "A" >
	| <K_ARRAY: "ARRAY" >
	| <K_AS: "AS" >
	| <K_AUTHID: "AUTHID" >
	| <K_AUTOMATIC: "AUTOMATIC" >
	| <K_AUTONOMOUS_TRANSACTION: "AUTONOMOUS_TRANSACTION" >
	| <K_BFILE: "BFILE" >
	| <K_BINARY_DOUBLE: "BINARY_DOUBLE" >
	| <K_BINARY_FLOAT: "BINARY_FLOAT" >
	| <K_BINARY_INTEGER: "BINARY_INTEGER" >
	| <K_BLOB: "BLOB" >
	| <K_BODY: "BODY" >
	| <K_BOOLEAN: "BOOLEAN" >
	| <K_BUILTIN: "BUILTIN" >
	| <K_BULK: "BULK" >
	| <K_BYTE: "BYTE" >
	| <K_CHAR: "CHAR" >
	| <K_CHARACTER: "CHARACTER" >
	| <K_CHARSET: "%CHARSET" >
	| <K_CLOB: "CLOB" >
	| <K_CLOSE: "CLOSE" >
	| <K_COLLECT: "COLLECT" >
	| <K_CONSTANT: "CONSTANT" >
	| <K_COUNT: "COUNT" >
	| <K_CREATE: "CREATE" >
	| <K_CROSS: "CROSS" >
	| <K_CUBE: "CUBE" >
	| <K_CURRENT_OF: "CURRENT_OF" >
	| <K_CURRENT_USER: "CURRENT_USER" >
	| <K_CURSOR: "CURSOR" >
	| <K_DATE: "DATE" >
	| <K_DAY: "DAY" >
	| <K_DBTIMEZONE: "DBTIMEZONE" >
	| <K_DEC: "DEC" >
	| <K_DECIMAL: "DECIMAL" >
	| <K_DECREMENT: "DECREMENT" >
	| <K_DEFAULT: "DEFAULT" >
	| <K_DEFINER: "DEFINER" >
	| <K_DETERMINISTIC: "DETERMINISTIC" >
	| <K_DIMENSION: "DIMENSION" >
	| <K_DOUBLE: "DOUBLE" >
	| <K_ELSIF: "ELSIF" >
	| <K_EMPTY: "EMPTY" >
	| <K_END: "END" >
	| <K_EQUALS_PATH: "EQUALS_PATH" >
	| <K_ESCAPE: "ESCAPE" >
    | <K_EXCEPTION: "EXCEPTION" >
	| <K_EXCEPTION_INIT: "EXCEPTION_INIT" >
	| <K_EXIT: "EXIT" >
	| <K_FALSE: "FALSE" >
	| <K_FIPSFLAG: "FIPSFLAG" >
	| <K_FIRST: "FIRST" >
	| <K_FLOAT: "FLOAT" >
	| <K_FULL: "FULL" >
	| <K_FUNCTION: "FUNCTION" >
	| <K_GROUPING: "GROUPING" >
	| <K_IGNORE: "IGNORE" >
	| <K_INCREMENT: "INCREMENT" >
	| <K_INFINITE: "INFINITE" >
	| <K_INLINE: "INLINE" >
	| <K_INNER: "INNER" >
	| <K_INT: "INT" >
	| <K_INTEGER: "INTEGER" >
	| <K_INTERFACE: "INTERFACE" >
	| <K_INTERVAL: "INTERVAL" >
	| <K_IS: "IS" >
	| <K_ITERATE: "ITERATE" >
	| <K_JOIN: "JOIN" >
	| <K_KEEP: "KEEP" >
	| <K_LAST: "LAST" >
	| <K_LEFT: "LEFT" >
	| <K_LIKE2: "LIKE2" >
	| <K_LIKE4: "LIKE4" >
	| <K_LIKEC: "LIKEC" >
	| <K_LOCAL: "LOCAL" >
	| <K_LONG: "LONG" >
	| <K_LOOP: "LOOP" >
	| <K_MAIN: "MAIN" >
	| <K_MEASURES: "MEASURES" >
	| <K_MEMBER: "MEMBER" >
	| <K_MLSLABEL: "MLSLABEL" >
	| <K_MODEL: "MODEL" >
	| <K_MONTH: "MONTH" >
	| <K_NAN: "NAN" >
	| <K_NATIONAL: "NATIONAL" >
	| <K_NATURAL: "NATURAL" >
	| <K_NAV: "NAV" >
	| <K_NCHAR: "NCHAR" >
	| <K_NCLOB: "NCLOB" >
	| <K_NEW: "NEW" >
	| <K_NEW_NAMES: "NEW_NAMES" >
	| <K_NO: "'NO'" >
	| <K_NOCYCLE: "NOCYCLE" >
	| <K_NOTNULL: "NOT NULL" >
	| <K_NULLS: "NULLS" >
	| <K_NUMBER: "NUMBER" >
	| <K_NUMERIC: "NUMERIC" >
	| <K_NVARCHAR2: "NVARCHAR2" >
	| <K_NVARCHAR: "NVARCHAR" >
	| <K_ONLY: "ONLY" >
	| <K_OPEN: "OPEN" >
	| <K_OR: "OR" >
	| <K_OUT: "OUT" >
	| <K_OUTER: "OUTER" >
	| <K_PACKAGE: "PACKAGE" >
	| <K_PARALLEL_ENABLE: "PARALLEL_ENABLE" >
	| <K_PARTITION: "PARTITION" >
	| <K_PIPELINED: "PIPELINED" >
	| <K_PLS_INTEGER: "PLS_INTEGER" >
	| <K_POSITIVE: "POSITIVE" >
	| <K_PRAGMA: "PRAGMA" >
	| <K_PRECISION: "PRECISION" >
	| <K_PRESENT: "PRESENT" >
	| <K_PROCEDURE: "PROCEDURE">     
	| <K_RAISE: "RAISE" >
	| <K_RANGE: "RANGE" >
	| <K_RAW: "RAW" >     
	| <K_READ: "READ" >
	| <K_REAL: "REAL" >
	| <K_RECORD: "RECORD" >
	| <K_REF: "REF" >
	| <K_REFERENCE: "REFERENCE" >
	| <K_REGEXP_LIKE: "REGEXP_LIKE" >
	| <K_REPLACE: "REPLACE" > 
	| <K_RESTRICT_REFERENCES: "RESTRICT_REFERENCES" >   
	| <K_RESULT_CACHE: "RESULT_CACHE" >
	| <K_RETURN: "RETURN" >  
	| <K_RETURNING: "RETURNING" >
	| <K_REVERSE: "REVERSE" >
	| <K_RIGHT: "RIGHT" >
	| <K_RNDS: "RNDS" >
	| <K_RNPS: "RNPS" >
	| <K_ROLLBACK: "ROLLBACK" >
	| <K_ROLLUP: "ROLLUP" >
	| <K_ROWID: "ROWID" >
    | <K_ROWTYPE: "%ROWTYPE" >
	| <K_RULES: "RULES" >
	| <K_SECOND: "SECOND" >
	| <K_SECONDS: "SECONDS" >
	| <K_SEQUENTIAL: "SEQUENTIAL" >
	| <K_SERIALLY_REUSABLE: "SERIALLY_REUSABLE" >
	| <K_SESSIONTIMEZONE: "SESSIONTIMEZONE" >
	| <K_SET: "SET" >
	| <K_SETS: "SETS" >
	| <K_SIBLINGS: "SIBLINGS" >
	| <K_SINGLE: "SINGLE" >
	| <K_SMALLINT: "SMALLINT" >
	| <K_SOME: "SOME" >
	| <K_SUBMUlookISET: "SUBMUlookISET" >
	| <K_SUBTYPE: "SUBTYPE" >
	| <K_THE: "THE" >
	| <K_TIME: "TIME" >
	| <K_TIMESTAMP: "TIMESTAMP" >
	| <K_TO: "TO" >
	| <K_TRANSACTION: "TRANSACTION" >
    | <K_TRUE: "TRUE" >
	| <K_TRUST: "TRUST" >
	| <K_TYPE: "TYPE" >
    | <K_TYPE2: "%TYPE" >
	| <K_UNDER_PATH: "UNDER_PATH" >
	| <K_UNTIL: "UNTIL" >
	| <K_UPDATED: "UPDATED" >
	| <K_UPSERT: "UPSERT" >
	| <K_UROWIDD: "UROWID" >
	| <K_USING: "USING" >
	| <K_VARCHAR2: "VARCHAR2" >
	| <K_VARCHAR: "VARCHAR" >
	| <K_VARRAY: "VARRAY" >
	| <K_VARYING: "VARYING" >
    | <K_WITH: "WITH" >
	| <K_WHILE: "WHILE" >
	| <K_WNDS: "WNDS" >
	| <K_WNPS: "WNPS" >
	| <K_WORK: "WORK" >
	| <K_YEAR: "YEAR" >
	| <K_YES: "'YES'" >
	| <K_ZONE: "ZONE" >
}

// basic character operators
TOKEN: {
      < ASSIGN: ":=" >
	| < ASTERISK: "*" >
    | < ATSIGN: "@" >
	| < CLOSEPAREN: ")" >
	| < CONCAT: "||" >
    | < COLON: ":" >
    | < COMMA: "," >
	| < DOT: "." >
    | < DOLLAR: "$" >
    | < PERCENT: "%" >
	| < EQUAL: "=" >
	| < GREATER: ">" >
	| < GREATEREQUAL: ">=" >
	| < JOINPLUS: "(+)" >
	| < LESS: "<" >
	| < LESSEQUAL: "<=" >
	| < MINUS: "-" >
	| < NOTEQUAL2: "<>" >
	| < NOTEQUAL: "!=" >
	| < OPENPAREN: "(" >
	| < PLUS: "+" >
    | < POUND: "#" >
	| < QUESTIONMARK: "?" >
	| < SEMICOLON: ";" >
	| < SLASH: "/" >
	| < TILDE: "~" >
}

TOKEN : { // numeric literals
    <S_NUMBER: <FLOAT>
        | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
      >
    | <#FLOAT: <INTEGER>
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
      >
    | <#INTEGER: ( <DIGIT> )+ >
    | <#DIGIT: ["0" - "9"] >
}

TOKEN:
{
    <S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> | <SPECIAL_CHARS>)* >
  | <#LETTER: ["a"-"z", "A"-"Z"] >
  | <#SPECIAL_CHARS: "$" | "_" | "#" | "@" >
  | <S_BIND: ":" ( <S_NUMBER> | <S_IDENTIFIER> ("." <S_IDENTIFIER>)?) >
  | <S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
  | <S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

String OracleObjectName():
{}
{
    <S_IDENTIFIER>
    {return token.image;}
  | <S_QUOTED_IDENTIFIER>
    {String s = token.image; return s.substring(1, s.length() - 1);}
}

// stripped-down version of PLSQL grammar: only parses package specifications
SimpleNode parsePLSQLPackage():
{String schema = null;
 String packageName = null;}
{     "CREATE" [ "OR" "REPLACE" ] "PACKAGE" [LOOKAHEAD(2) schema=OracleObjectName() "." ] packageName=OracleObjectName()
     [ "AUTHID" [ "CURRENT_USER" | "DEFINER" ] ]
     [ "AS" | "IS" ]
         ( packageSpec() )*
     endPackageSpec()
    {
      PLSQLPackageNode packageNode = new PLSQLPackageNode();
      if (schema != null) {
        packageNode.setPackageName(schema + "." + packageName);      }      else {
        packageNode.setPackageName(packageName);      }
      ((PLSQLNode)jjtThis).setPackageNode(packageNode);
      return jjtThis;
    }
}

void endPackageSpec():
{String packageName = null;} 
{    "END" [ packageName=OracleObjectName() ] ";"
    {
      if (packageName != null) {
        //TODO - find PLSQLPackageNode by name
        System.identityHashCode(jjtThis);
      }
      else {
        //TODO - get 'current' PLSQLPackageNode
        System.identityHashCode(jjtThis);
      }
    }
}

void packageSpec():
{}
{
    LOOKAHEAD(2) variableDeclaration()
    | typeDeclaration()
    | cursorDeclaration()
    | procedureSpec()
    | functionSpec()
    | exceptionDeclaration()
    | pragmaDeclaration()
}

void variableDeclaration():
{}
{
    <S_IDENTIFIER> [ "CONSTANT" ] typeSpec() [ "NOT NULL" ]
        [[ ":=" | "DEFAULT" ] expr_skipToSemicolon() ]
    ";"}

void datatype():
{}
{
    "BINARY_INTEGER"
    | "BINARY_FLOAT"
    | "BINARY_DOUBLE"
    | "NATURAL"
    | "POSITIVE"
    | ( "NUMBER" | "NUMERIC" | "DECIMAL" | "DEC" ) [ "(" <S_NUMBER> ( "," <S_NUMBER> )* ")" ]
    | "LONG" [ "RAW" ] [ "(" <S_NUMBER> ")" ]
    | "RAW" [ "(" <S_NUMBER> ")" ]
    | "BOOLEAN"
    | "DATE"
    | LOOKAHEAD(2) "INTERVAL" "DAY" [ "(" <S_NUMBER> ")" ] "TO" "SECONDS" [ "(" <S_NUMBER> ")" ]
    | "INTERVAL" "YEAR" [ "(" <S_NUMBER> ")" ] "TO" "MONTH"
    | ( "TIME" |"TIMESTAMP") [ "(" <S_NUMBER> ")" ] [ "WITH" [ "LOCAL"] "TIME" "ZONE" ]
    | "INTEGER"
    | "INT"
    | "SMALLINT"
    | "FLOAT" [ "(" <S_NUMBER> ")" ]
    | "REAL"
    | "MLSLABEL"
    | "PLS_INTEGER"
    | "BLOB"
    | "NCLOB"
    | "BFILE"
    | "ROWID"
    | "UROWID" [ "(" <S_NUMBER> ")" ]
    | "DOUBLE" "PRECISION"
    | "CHAR" [ "VARYING" ] [ "(" <S_NUMBER> [ "BYTE" | "CHAR" ] ")" ] [ "CHARACTER" "SET" [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() "%CHARSET" ] ]
    | "VARCHAR" [ "VARYING" ] [ "(" <S_NUMBER> [ "BYTE" | "CHAR" ] ")" ] [ "CHARACTER" "SET" [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() "%CHARSET" ] ]
    | "VARCHAR2" [ "VARYING" ] [ "(" <S_NUMBER> [ "BYTE" | "CHAR" ] ")" ] [ "CHARACTER" "SET" [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() "%CHARSET" ] ]
    | "CHARACTER" [ "VARYING" ] [ "(" <S_NUMBER> ")" ] 
    | "NCHAR" [ "VARYING" ] [ "(" <S_NUMBER> ")" ] 
    | "NVARCHAR" [ "(" <S_NUMBER> ")" ] 
    | "NVARCHAR2" [ "(" <S_NUMBER> ")" ]
    | "NATIONAL" ( "CHARACTER" |"CHAR" ) [ "VARYING" ] [ "(" <S_NUMBER> ")" ] 
    | "CLOB" [ "CHARACTER" "SET" [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() "%CHARSET" ] ]
}

void typeSpec():
{}
{  
    datatype()
    | LOOKAHEAD(3) columnSpec() "%TYPE"
    | LOOKAHEAD(3) tableSpec() "%ROWTYPE"
    | typeName() [ "(" <S_NUMBER> ")" ]   
}

String columnSpec():
{}
{
    OracleObjectName() [ "." OracleObjectName() [ "." OracleObjectName() ] ]
    {return token.image;}
}

String tableSpec():
{}
{
    OracleObjectName() [ "." OracleObjectName() [ <ATSIGN> <S_IDENTIFIER> ] ]
    {return token.image;}
}

String typeName():
{}
{
    OracleObjectName() [ "." OracleObjectName() ]
    {return token.image;}
}

JAVACODE
void expr_skipToSemicolon() {
	Token tok;
	while (true) {
        tok = getToken(1);
        if (tok.kind == SEMICOLON) {
            break;
        }
        tok = getNextToken();
    }
}

JAVACODE
void expr_skipToNextArg() {
    Token tok;
    while (true) {
        tok = getToken(1);
        if (tok.kind == COMMA || tok.kind == CLOSEPAREN) {
            break;
        }
        tok = getNextToken();
    }
}
    
SimpleNode typeDeclaration():
{String s = null;}
{
    "TYPE" s=typeName() "IS" 
        aTypeDeclaration() 
    ";"
    {
      jjtThis.jjtSetValue(s);
      return jjtThis;
    }
}

void aTypeDeclaration():
{}
{
    recordDeclaration()
    | subtypeDeclaration()
    | plsqlTableDeclaration()
    | varrayDeclaration()
    | refCursorDeclaration()
}

void subtypeDeclaration():
{}
{
    expr_skipToSemicolon()
}

SimpleNode recordDeclaration():
{}
{
    "RECORD" "("
        fieldDeclarations()
    ")"
    {
      return jjtThis;
    }
}

void fieldDeclarations():
{}
{
    fieldDeclaration() ( "," fieldDeclaration() )*
}

SimpleNode fieldDeclaration():
{String s = null;}
{
    s=typeName() typeSpec() [ "NOT NULL" ]
        [[ ":=" | "DEFAULT" ] expr_skipToNextArg() ]
    {
      jjtThis.jjtSetValue(s);
      return jjtThis;
    }
}

void plsqlTableDeclaration():
{}
{
    expr_skipToSemicolon()
}

void varrayDeclaration():
{}
{
    expr_skipToSemicolon()
}

void refCursorDeclaration():
{}
{
    expr_skipToSemicolon()
}

SimpleNode cursorDeclaration():
{Token t = null;}
{
    "CURSOR" t=<S_IDENTIFIER>
    ";"
    {
      jjtThis.jjtSetValue(t.image);
      return jjtThis;
    }
}

void cursorSpec():
{}
{
   expr_skipToSemicolon()
}

// Procedure Specification
SimpleNode procedureSpec():
{Token t = null;}
{
    "PROCEDURE" t=<S_IDENTIFIER>
        [ "(" argumentList() ")" ]
    ";" 
    {
      jjtThis.jjtSetValue(t.image);
      return jjtThis;
    }
}

void argumentList():
{}
{
   argument() ( "," argument() )*
}

SimpleNode functionSpec():
{Token t = null;}
{
    "FUNCTION" t=<S_IDENTIFIER>
        argumentList()
        "RETURN" <S_IDENTIFIER> [ "%TYPE" | "%ROWTYPE" ]
        [ "DETERMINISTIC" | "PIPELINED" | "PARALLEL_ENABLE" | "RESULT_CACHE" ]
    ";"
    {
      jjtThis.jjtSetValue(t.image);
      return jjtThis;
    }
}

void argument():
{}
{
   expr_skipToNextArg()
}

void exceptionDeclaration():
{}
{
    <S_IDENTIFIER> "EXCEPTION" 
    ";"
}

void pragmaDeclaration():
{}
{    "PRAGMA"
    [ "AUTONOMOUS_TRANSACTION"
    | "EXCEPTION_INIT" "(" <S_IDENTIFIER> "," < S_NUMBER> ")"
    | "SERIALLY_REUSABLE"
    | "INLINE" "(" <S_IDENTIFIER> "," [ "'YES'" | "'NO'" ] ")"
    | "RESTRICT_REFERENCES" "(" [ <S_IDENTIFIER> | "DEFAULT" ]
        ( "," [ "RNDS" | "WNDS" | "RNPS" | "WNPS" | "TRUST"] )+ ")"
    ]
    ";"
}