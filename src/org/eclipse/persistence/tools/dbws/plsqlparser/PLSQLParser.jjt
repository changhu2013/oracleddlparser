/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 
 * which accompanies this distribution. 
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
options {
    MULTI = false;
    STATIC = true;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
    VISITOR = true;
    NODE_CLASS = "PLSQLNode";
    SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
    TRACK_TOKENS = true;
    //DEBUG_PARSER = true;
}
PARSER_BEGIN(PLSQLParser)
/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 
 * which accompanies this distribution. 
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
package org.eclipse.persistence.tools.dbws.plsqlparser;

public class PLSQLParser {

    public PLSQLParser() {
      super();
    }
    
    public static void main( String args[] ) throws ParseException {
        PLSQLParser p = null ;
        if (args.length < 1) {
            System.out.println("Reading from stdin") ;
            p = new PLSQLParser(System.in) ;
        }
        else {
            try {
                p = new PLSQLParser(new java.io.DataInputStream(
                                new java.io.FileInputStream(args[0]))) ;
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new PLSQLParser(System.in) ;
            }
        }
        SimpleNode sn = p.parsePLSQLPackage();
        sn.dump(">");
    }
}

PARSER_END(PLSQLParser)

// white-space
SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}
// comments
SKIP: {
    <COMMENT_LINE: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}
SKIP:{
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// PLSQL keywords (NB: may not be a complete list)
TOKEN: {
    <K_A: "A">
	| <K_ARRAY: "ARRAY">
	| <K_AS: "AS">
	| <K_AUTHID: "AUTHID">
	| <K_AUTOMATIC: "AUTOMATIC">
	| <K_AUTONOMOUS_TRANSACTION: "AUTONOMOUS_TRANSACTION">
	| <K_BFILE: "BFILE">
	| <K_BINARY_DOUBLE: "BINARY_DOUBLE">
	| <K_BINARY_FLOAT: "BINARY_FLOAT">
	| <K_BINARY_INTEGER: "BINARY_INTEGER">
	| <K_BLOB: "BLOB">
	| <K_BODY: "BODY">
	| <K_BOOLEAN: "BOOLEAN">
	| <K_BUILTIN: "BUILTIN">
	| <K_BULK: "BULK">
    | <K_BY: "BY">
	| <K_BYTE: "BYTE">
	| <K_CHAR: "CHAR">
	| <K_CHARACTER: "CHARACTER">
	| <K_CHARSET: "%CHARSET">
	| <K_CLOB: "CLOB">
	| <K_CLOSE: "CLOSE">
	| <K_COLLECT: "COLLECT">
	| <K_CONSTANT: "CONSTANT">
	| <K_COUNT: "COUNT">
	| <K_CREATE: "CREATE">
	| <K_CROSS: "CROSS">
	| <K_CUBE: "CUBE">
	| <K_CURRENT_OF: "CURRENT_OF">
	| <K_CURRENT_USER: "CURRENT_USER">
	| <K_CURSOR: "CURSOR">
	| <K_DATE: "DATE">
	| <K_DAY: "DAY">
	| <K_DBTIMEZONE: "DBTIMEZONE">
	| <K_DEC: "DEC">
	| <K_DECIMAL: "DECIMAL">
	| <K_DECREMENT: "DECREMENT">
	| <K_DEFAULT: "DEFAULT">
	| <K_DEFINER: "DEFINER">
	| <K_DETERMINISTIC: "DETERMINISTIC">
	| <K_DIMENSION: "DIMENSION">
	| <K_DOUBLE: "DOUBLE">
	| <K_ELSIF: "ELSIF">
	| <K_EMPTY: "EMPTY">
	| <K_END: "END">
	| <K_EQUALS_PATH: "EQUALS_PATH">
	| <K_ESCAPE: "ESCAPE">
    | <K_EXCEPTION: "EXCEPTION">
	| <K_EXCEPTION_INIT: "EXCEPTION_INIT">
	| <K_EXIT: "EXIT">
	| <K_FALSE: "FALSE">
	| <K_FIPSFLAG: "FIPSFLAG">
	| <K_FIRST: "FIRST">
	| <K_FLOAT: "FLOAT">
	| <K_FULL: "FULL">
	| <K_FUNCTION: "FUNCTION">
	| <K_GROUPING: "GROUPING">
	| <K_IGNORE: "IGNORE">
    | <K_IN: "IN">
	| <K_INCREMENT: "INCREMENT">
    | <K_INDEX: "INDEX">
	| <K_INFINITE: "INFINITE">
	| <K_INLINE: "INLINE">
	| <K_INNER: "INNER">
	| <K_INT: "INT">
	| <K_INTEGER: "INTEGER">
	| <K_INTERFACE: "INTERFACE">
	| <K_INTERVAL: "INTERVAL">
	| <K_IS: "IS">
	| <K_ITERATE: "ITERATE">
	| <K_JOIN: "JOIN">
	| <K_KEEP: "KEEP">
	| <K_LAST: "LAST">
	| <K_LEFT: "LEFT">
	| <K_LIKE2: "LIKE2">
	| <K_LIKE4: "LIKE4">
	| <K_LIKEC: "LIKEC">
	| <K_LOCAL: "LOCAL">
	| <K_LONG: "LONG">
	| <K_LOOP: "LOOP">
	| <K_MAIN: "MAIN">
	| <K_MEASURES: "MEASURES">
	| <K_MEMBER: "MEMBER">
	| <K_MLSLABEL: "MLSLABEL">
	| <K_MODEL: "MODEL">
	| <K_MONTH: "MONTH">
	| <K_NAN: "NAN">
	| <K_NATIONAL: "NATIONAL">
	| <K_NATURAL: "NATURAL">
	| <K_NAV: "NAV">
	| <K_NCHAR: "NCHAR">
	| <K_NCLOB: "NCLOB">
	| <K_NEW: "NEW">
	| <K_NEW_NAMES: "NEW_NAMES">
	| <K_NO: "'NO'">
	| <K_NOCYCLE: "NOCYCLE">
	| <K_NOCOPY: "NOCOPY">
    | <K_NOT: "NOT">
	| <K_NULL: "NULL">
	| <K_NULLS: "NULLS">
	| <K_NUMBER: "NUMBER">
	| <K_NUMERIC: "NUMERIC">
	| <K_NVARCHAR2: "NVARCHAR2">
	| <K_NVARCHAR: "NVARCHAR">
    | <K_OF: "OF">
	| <K_ONLY: "ONLY">
	| <K_OPEN: "OPEN">
	| <K_OR: "OR">
	| <K_OUT: "OUT">
	| <K_OUTER: "OUTER">
	| <K_PACKAGE: "PACKAGE">
	| <K_PARALLEL_ENABLE: "PARALLEL_ENABLE">
	| <K_PARTITION: "PARTITION">
	| <K_PIPELINED: "PIPELINED">
	| <K_PLS_INTEGER: "PLS_INTEGER">
	| <K_POSITIVE: "POSITIVE">
	| <K_PRAGMA: "PRAGMA">
	| <K_PRECISION: "PRECISION">
	| <K_PRESENT: "PRESENT">
	| <K_PROCEDURE: "PROCEDURE">     
	| <K_RAISE: "RAISE">
	| <K_RANGE: "RANGE">
	| <K_RAW: "RAW">     
	| <K_READ: "READ">
	| <K_REAL: "REAL">
	| <K_RECORD: "RECORD">
	| <K_REF: "REF">
	| <K_REFERENCE: "REFERENCE">
	| <K_REGEXP_LIKE: "REGEXP_LIKE">
	| <K_REPLACE: "REPLACE"> 
	| <K_RESTRICT_REFERENCES: "RESTRICT_REFERENCES">   
	| <K_RESULT_CACHE: "RESULT_CACHE">
	| <K_RETURN: "RETURN">  
	| <K_RETURNING: "RETURNING">
	| <K_REVERSE: "REVERSE">
	| <K_RIGHT: "RIGHT">
	| <K_RNDS: "RNDS">
	| <K_RNPS: "RNPS">
	| <K_ROLLBACK: "ROLLBACK">
	| <K_ROLLUP: "ROLLUP">
	| <K_ROWID: "ROWID">
    | <K_ROWTYPE: "%ROWTYPE">
	| <K_RULES: "RULES">
	| <K_SECOND: "SECOND">
	| <K_SECONDS: "SECONDS">
	| <K_SEQUENTIAL: "SEQUENTIAL">
	| <K_SERIALLY_REUSABLE: "SERIALLY_REUSABLE">
	| <K_SESSIONTIMEZONE: "SESSIONTIMEZONE">
	| <K_SET: "SET">
	| <K_SETS: "SETS">
	| <K_SIBLINGS: "SIBLINGS">
	| <K_SINGLE: "SINGLE">
	| <K_SMALLINT: "SMALLINT">
	| <K_SOME: "SOME">
    | <K_STRING: "STRING">
	| <K_SUBMUlookISET: "SUBMUlookISET">
	| <K_SUBTYPE: "SUBTYPE">
    | <K_TABLE: "TABLE">
	| <K_THE: "THE">
	| <K_TIME: "TIME">
	| <K_TIMESTAMP: "TIMESTAMP">
	| <K_TO: "TO">
	| <K_TRANSACTION: "TRANSACTION">
    | <K_TRUE: "TRUE">
	| <K_TRUST: "TRUST">
	| <K_TYPE: "TYPE">
    | <K_TYPE2: "%TYPE">
	| <K_UNDER_PATH: "UNDER_PATH">
	| <K_UNTIL: "UNTIL">
	| <K_UPDATED: "UPDATED">
	| <K_UPSERT: "UPSERT">
	| <K_UROWIDD: "UROWID">
	| <K_USING: "USING">
	| <K_VARCHAR2: "VARCHAR2">
	| <K_VARCHAR: "VARCHAR">
	| <K_VARRAY: "VARRAY">
	| <K_VARYING: "VARYING">
    | <K_WITH: "WITH">
	| <K_WHILE: "WHILE">
	| <K_WNDS: "WNDS">
	| <K_WNPS: "WNPS">
	| <K_WORK: "WORK">
	| <K_YEAR: "YEAR">
	| <K_YES: "'YES'">
	| <K_ZONE: "ZONE">
}

// operators
TOKEN: {
      <O_ASSIGN: ":=">
	| <O_ASTERISK: "*">
    | <O_ATSIGN: "@">
	| <O_CLOSEPAREN: ")">
	| <O_CONCAT: "||">
    | <O_COLON: ":">
    | <O_COMMA: ",">
	| <O_DOT: ".">
    | <O_DOUBLEDOT: "..">
    | <O_DOLLAR: "$">
    | <O_PERCENT: "%">
	| <O_EQUAL: "=">
	| <O_GREATER: ">">
	| <O_GREATEREQUAL: ">=">
	| <O_JOINPLUS: "(+)">
	| <O_LESS: "<">
	| <O_LESSEQUAL: "<=">
	| <O_MINUS: "-">
	| <O_NOTEQUAL2: "<>">
	| <O_NOTEQUAL: "!=">
	| <O_OPENPAREN: "(">
	| <O_PLUS: "+">
    | <O_POUND: "#">
	| <O_QUESTIONMARK: "?">
	| <O_SEMICOLON: ";">
	| <O_SLASH: "/">
	| <O_TILDE: "~">
}

// numeric literals
TOKEN : {
    <S_NUMBER: <FLOAT>
        | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
      >
    | <#FLOAT: <INTEGER>
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
      >
    | <#INTEGER: ( <DIGIT> )+ >
    | <#DIGIT: ["0" - "9"] >
}

// identifiers
TOKEN:
{
    <S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> | <SPECIAL_CHARS>)* >
  | <#LETTER: ["a"-"z", "A"-"Z"] >
  | <#SPECIAL_CHARS: "$" | "_" | "#" | "@" >
  | <S_BIND: ":" ( <S_NUMBER> | <S_IDENTIFIER> ("." <S_IDENTIFIER>)?) >
  | <S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
  | <S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

// stripped-down version of PLSQL grammar: only parses package specifications
PLSQLNode parsePLSQLPackage():
{String schema = null;
 String packageName = null;}
{
    <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_PACKAGE>
        [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] packageName=OracleObjectName()
        [ <K_AUTHID> [ <K_CURRENT_USER> | <K_DEFINER> ] ]
        [ <K_AS> | <K_IS> ]
         ( packageDeclaration() )*
     <K_END> [ packageName=OracleObjectName() ] <O_SEMICOLON>
     <EOF>
    {
      PLSQLPackageNode packageNode = new PLSQLPackageNode();
      if (schema != null) {
        packageNode.setPackageName(schema + "." + packageName);      }      else {
        packageNode.setPackageName(packageName);      }
      ((PLSQLNode)jjtThis).setPackageNode(packageNode);
      jjtThis.jjtSetValue(packageNode.getPackageName());
      return jjtThis;
    }
}

void packageDeclaration() #void:
{}
{
    LOOKAHEAD(2) variableDeclaration()
    | typeDeclaration()
    | cursorDeclaration()
    | procedureSpec()
    | functionSpec()
    | exceptionDeclaration()
    | pragmaDeclaration()
}

void variableDeclaration():
{}
{
    <S_IDENTIFIER> [ <K_CONSTANT> ] typeSpec() [ <K_NOT> <K_NULL> ]
        [ variableDefaultAssignment() ]
    <O_SEMICOLON>}

void variableDefaultAssignment() #void:
{}
{
    ( <O_ASSIGN> | <K_DEFAULT> ) skipToSemiColon()
}

void datatype() #void:
{}
{
    <K_BINARY_INTEGER>
    | <K_BINARY_FLOAT>
    | <K_BINARY_DOUBLE>
    | <K_NATURAL>
    | <K_POSITIVE>
    | ( <K_NUMBER>
        | <K_NUMERIC>
        | <K_DECIMAL>
        | <K_DEC>
      ) [ <O_OPENPAREN> <S_NUMBER> ( <O_COMMA> <S_NUMBER> )* <O_CLOSEPAREN> ]
    | <K_LONG> [ <K_RAW> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_RAW> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_BOOLEAN>
    | <K_DATE>
    | LOOKAHEAD(2) <K_INTERVAL> <K_DAY> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] <K_TO> <K_SECONDS> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_INTERVAL> <K_YEAR> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] <K_TO> <K_MONTH>
    | ( <K_TIME>
        | <K_TIMESTAMP>
      ) [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] [ <K_WITH> [ <K_LOCAL> ] <K_TIME> <K_ZONE> ]
    | <K_INTEGER>
    | <K_INT>
    | <K_SMALLINT>
    | <K_FLOAT> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_REAL>
    | <K_MLSLABEL>
    | <K_PLS_INTEGER>
    | <K_BLOB >
    | <K_NCLOB>
    | <K_BFILE>
    | <K_ROWID>
    | <K_UROWIDD> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_DOUBLE> <K_PRECISION>
    | <K_CHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ] 
    | <K_VARCHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ] 
    | <K_VARCHAR2> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
    | <K_CHARACTER> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] 
    | <K_NCHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] 
    | <K_NVARCHAR> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] 
    | <K_NVARCHAR2> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NATIONAL> ( <K_CHARACTER> | <K_CHAR> ) [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] 
    | <K_CLOB> [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
}

String typeSpec():
{String s = null;}
{
    (      datatype()
    | LOOKAHEAD(3) columnSpec() <K_TYPE2>
    | LOOKAHEAD(3) tableSpec() <K_ROWTYPE>
    | typeName() [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    )
    {
      Token first = jjtThis.jjtGetFirstToken();
      Token last = jjtThis.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder();
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);      }
      jjtThis.jjtSetValue(sb.toString());
      return sb.toString();    }
}

String columnSpec() #void:
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() [ <O_DOT> OracleObjectName() ] ]
    {return token.image;}
}

String tableSpec() #void:
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() [ <O_ATSIGN> <S_IDENTIFIER> ] ]
    {return token.image;}
}

String typeName() #void:
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() ]
    {return token.image;}
}
    
PLSQLNode typeDeclaration():
{String s = null;}
{
    <K_TYPE> s=typeName() <K_IS>
        aTypeDeclaration() 
    <O_SEMICOLON>
    {
      jjtThis.jjtSetValue(s);
      return jjtThis;
    }
}

void aTypeDeclaration() #void:
{}
{
    recordDeclaration()
    | subtypeDeclaration()
    | plsqlTableDeclaration()
    | varrayDeclaration()
    | refCursorDeclaration()
}

PLSQLNode recordDeclaration():
{}
{
    <K_RECORD> <O_OPENPAREN>
        fieldDeclarations()
    <O_CLOSEPAREN>
    { jjtThis.jjtSetValue("RECORD");
      return jjtThis; }
}

void fieldDeclarations() #void:
{}
{
    fieldDeclaration() ( <O_COMMA> fieldDeclaration() )*
}

PLSQLNode fieldDeclaration():
{String s = null;
}
{
    s=typeName() typeSpec() [ <K_NOT> <K_NULL> ] [ variableDefaultAssignment() ]
    {
      jjtThis.jjtSetValue(s);
      return jjtThis;
    }
}

PLSQLNode subtypeDeclaration():
{}
{
    <K_SUBTYPE> OracleObjectName() <K_IS> datatype()
        ( <K_RANGE> <S_NUMBER> <O_DOUBLEDOT> <S_NUMBER>
        | <S_NUMBER> [ <O_COMMA> <S_NUMBER> ]
        | <K_CHARACTER> <K_SET> <S_IDENTIFIER>
        ) [ <K_NOT> <K_NULL> ] 
    { return jjtThis; }
}

PLSQLNode plsqlTableDeclaration():
{}
{
    <K_TABLE> <K_OF> datatype() [ <K_NOT> <K_NULL> ] <K_INDEX> <K_BY>
        ( <K_PLS_INTEGER >
        | <K_BINARY_INTEGER>
        | <K_VARCHAR2> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
        | <K_STRING> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
        )
    { return jjtThis; }
}

PLSQLNode varrayDeclaration():
{}
{
    ( <K_VARRAY> | <K_VARYING> <K_ARRAY> ) <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
        <K_OF> datatype() [ <K_NOT> <K_NULL> ]
    { return jjtThis; }
}

PLSQLNode refCursorDeclaration():
{String s = null;}
{
    <K_REF> <K_CURSOR> [ refCursorTypeSpec() ]
    {
      jjtThis.jjtSetValue("REF CURSOR");
      return jjtThis;
    }
}

PLSQLNode refCursorTypeSpec():
{String s = null;}
{
    <K_RETURN> [LOOKAHEAD(3) s=columnSpec() [ <K_TYPE2> ]
    | LOOKAHEAD(3) s=tableSpec() [ <K_ROWTYPE> ] ]
    {
      jjtThis.jjtSetValue("RETURN " +s);
      return jjtThis;
    }
}

PLSQLNode cursorDeclaration():
{Token t = null;}
{
    <K_CURSOR> t=<S_IDENTIFIER>
    <O_SEMICOLON>
    {
      jjtThis.jjtSetValue(t.image);
      return jjtThis;
    }
}

// Procedure Specification
PLSQLNode procedureSpec():
{Token t = null;}
{
    <K_PROCEDURE> t=<S_IDENTIFIER>
        [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ]
    <O_SEMICOLON> 
    {
      jjtThis.jjtSetValue("PROCEDURE " + t.image);
      return jjtThis;
    }
}

void argumentList() #void:
{}
{
   argument() ( <O_COMMA> argument() )*
}

// Function Specification
PLSQLNode functionSpec():
{Token t = null;}
{
    <K_FUNCTION> t=<S_IDENTIFIER>
        [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ]
        functionReturnSpec()
        [ <K_DETERMINISTIC> | <K_PIPELINED> | <K_PARALLEL_ENABLE> | <K_RESULT_CACHE> ]
    <O_SEMICOLON> 
    {
      jjtThis.jjtSetValue("FUNCTION " + t.image);
      return jjtThis;
    }
}

PLSQLNode functionReturnSpec():
{}{    (<K_RETURN> typeSpec())
    {
      jjtThis.jjtSetValue("RETURN");
      return jjtThis;
    }
}

PLSQLNode argument():
{Token t = null;
 Token directionToken = null;
 String direction = null;
}
{
    t=<S_IDENTIFIER> [( LOOKAHEAD(2) directionToken=<K_IN> | directionToken=<K_OUT> | direction=inOut())]
        [ <K_NOCOPY> ] typeSpec() [ argumentDefaultAssignment() ]
    {
      if (directionToken != null) {
          jjtThis.jjtSetValue(directionToken.image + " " + t.image);
      }
      else if (direction != null) {
          jjtThis.jjtSetValue(direction + " " + t.image);
      }
      else {
          // by default, arguments are IN
          jjtThis.jjtSetValue("IN " + t.image);
      }
      return jjtThis;
    }
}


String inOut() #void:
{}
{
    <K_IN> <K_OUT>
    { return "IN OUT"; }
}   

PLSQLNode argumentDefaultAssignment():
{}
{
    ( <O_ASSIGN> | <K_DEFAULT> ) skipToNextArg()
    {
      jjtThis.jjtSetValue(" (optional)");
      return jjtThis;
    }
}    

void exceptionDeclaration() #void:
{}
{
    <S_IDENTIFIER> <K_EXCEPTION> 
    <O_SEMICOLON>
}

void pragmaDeclaration() #void:
{}
{    <K_PRAGMA>
    [ <K_AUTONOMOUS_TRANSACTION>
    | <K_EXCEPTION_INIT> <O_OPENPAREN> <S_IDENTIFIER> <O_COMMA> <S_NUMBER> <O_CLOSEPAREN>
    | <K_SERIALLY_REUSABLE>
    | <K_INLINE> <O_OPENPAREN> <S_IDENTIFIER> <O_COMMA> [ <K_YES> | <K_NO> ] <O_CLOSEPAREN>
    | <K_RESTRICT_REFERENCES> <O_OPENPAREN> [ <S_IDENTIFIER> | <K_DEFAULT> ]
        ( <O_COMMA> [ <K_RNDS> | <K_WNDS> | <K_RNPS> | <K_WNPS> | <K_TRUST>] )+ <O_CLOSEPAREN>
    ]
    <O_SEMICOLON>
}

String OracleObjectName() #void:
{}
{
    <S_IDENTIFIER>
    {return token.image;}
  | <S_QUOTED_IDENTIFIER>
    {
      String s = token.image;
      return s.substring(1, s.length() - 1); // strip-off quotes
    }
}

void skipToSemiColon() #void:
{}
{
    {
        Token t = getNextToken();
        while (t.kind != O_SEMICOLON) {          t = getNextToken();
        }
        token_source.input_stream.backup(1);
    }
}

void skipToNextArg() #void:
{}
{   
    {
        Token t = getNextToken();
        while (t.kind != O_COMMA && t.kind != O_CLOSEPAREN) {
          t = getNextToken();
        }
        token_source.input_stream.backup(1);
    }
}