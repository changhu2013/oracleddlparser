/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. PLSQLParser.jj */
/*@egen*//*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 
 * which accompanies this distribution. 
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
options {
    STATIC = true;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = false;
    IGNORE_CASE = true;
                   
                             
    SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
	/*
	MULTI=false
	NODE_USES_PARSER=false
	TRACK_TOKENS=false
	NODE_PREFIX=AST
	NODE_EXTENDS=
	NODE_FACTORY=
	*/
}
PARSER_BEGIN(PLSQLParser)
/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the 
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0 
 * which accompanies this distribution. 
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
package org.eclipse.persistence.tools.dbws.plsqlparser;

public class PLSQLParser/*@bgen(jjtree)*/implements PLSQLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTPLSQLParserState jjtree = new JJTPLSQLParserState();

/*@egen*/

    public PLSQLParser() {
      super();
    }
    
    public static void main( String args[] ) throws ParseException {
        PLSQLParser p = null ;
        if (args.length < 1) {
            System.out.println("Reading from stdin") ;
            p = new PLSQLParser(System.in) ;
        }
        else {
            try {
                p = new PLSQLParser(new java.io.DataInputStream(
                                new java.io.FileInputStream(args[0]))) ;
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new PLSQLParser(System.in) ;
            }
        }
        SimpleNode sn = p.parsePLSQLPackage();
        sn.dump(">");
    }
}

PARSER_END(PLSQLParser)

// white-space
SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

// comments
SKIP: {
    <COMMENT_LINE: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP:{
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// PLSQL keywords (not a complete list)
TOKEN: {
      <K_AS: "AS" >
	| <K_AUTHID: "AUTHID" >
	| <K_AUTONOMOUS_TRANSACTION: "AUTONOMOUS_TRANSACTION">
	| <K_CREATE: "CREATE" >
	| <K_CURRENT_USER: "CURRENT_USER" >
	| <K_CURSOR: "CURSOR" >
    | <K_DEFAULT: "DEFAULT" >
    | <K_DEFINER: "DEFINER" >
	| <K_DETERMINISTIC: "DETERMINISTIC" >
	| <K_END: "END" >
    | <K_EXCEPTION_INIT: "EXCEPTION_INIT" >
	| <K_FUNCTION: "FUNCTION" >
	| <K_INLINE: "INLINE" >
	| <K_IS: "IS" >
	| <K_OR: "OR" >
    | <K_NO: "'NO'" >
	| <K_PACKAGE: "PACKAGE" >
	| <K_PARALLEL_ENABLE: "PARALLEL_ENABLE" >
	| <K_PIPELINED: "PIPELINED" >
	| <K_PRAGMA: "PRAGMA">  
    | <K_PROCEDURE: "PROCEDURE">      
	| <K_REPLACE: "REPLACE" >   
    | <K_RESTRICT_REFERENCES: "RESTRICT_REFERENCES" >   
	| <K_RESULT_CACHE: "RESULT_CACHE" >
	| <K_RETURN: "RETURN" >  
    | <K_RNDS: "RNDS" >
    | <K_RNPS: "RNPS" >
	| <K_SERIALLY_REUSABLE: "SERIALLY_REUSABLE" >
    | <K_TRUST: "TRUST" >
	| <K_TYPE: "TYPE" >
    | <K_WNDS: "WNDS" >
    | <K_WNPS: "WNPS" >
    | <K_YES: "'YES'" >
}

// basic operators
TOKEN: {
      < ASSIGN: ":=" >
	| < ASTERISK: "*" >
	| < CLOSEPAREN: ")" >
	| < CONCAT: "||" >
    | < COLON: ":" >
	| < DOT: "." >
	| < EQUAL: "=" >
	| < GREATER: ">" >
	| < GREATEREQUAL: ">=" >
	| < JOINPLUS: "(+)" >
	| < LESS: "<" >
	| < LESSEQUAL: "<=" >
	| < MINUS: "-" >
	| < NOTEQUAL2: "<>" >
	| < NOTEQUAL: "!=" >
	| < OPENPAREN: "(" >
	| < PLUS: "+" >
	| < QUESTIONMARK: "?" >
	| < ROWTYPE: "%ROWTYPE" >
	| < SEMICOLON: ";" >
	| < SLASH: "/" >
	| < TILDE: "~" >
    | < TYPE: "%TYPE" >
}

TOKEN : { // numeric literals
    <S_NUMBER: <FLOAT>
        | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
      >
    | <#FLOAT: <INTEGER>
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
      >
    | <#INTEGER: ( <DIGIT> )+ >
    | <#DIGIT: ["0" - "9"] >
}

TOKEN:
{
    <S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> | <SPECIAL_CHARS>)* >
  | <#LETTER: ["a"-"z", "A"-"Z"] >
  | <#SPECIAL_CHARS: "$" | "_" | "#" | "@" >
  | <S_BIND: ":" ( <S_NUMBER> | <S_IDENTIFIER> ("." <S_IDENTIFIER>)?) >
  | <S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
  | <S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

String OracleObjectName():
{/*@bgen(jjtree) OracleObjectName */
  PLSQLNode jjtn000 = new PLSQLNode(JJTORACLEOBJECTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OracleObjectName */
    try {
/*@egen*/
    <S_IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return token.image;}
  | <S_QUOTED_IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {String s = token.image; return s.substring(1, s.length() - 1);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// stripped-down version of PLSQL grammar: only parses package specifications
SimpleNode parsePLSQLPackage():
{/*@bgen(jjtree) parsePLSQLPackage */
 PLSQLNode jjtn000 = new PLSQLNode(JJTPARSEPLSQLPACKAGE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String schema = null;
 String packageName = null;}
{/*@bgen(jjtree) parsePLSQLPackage */
    try {
/*@egen*/     "CREATE" [ "OR" "REPLACE" ] "PACKAGE" [LOOKAHEAD(2) schema=OracleObjectName() "." ] packageName=OracleObjectName()
     [ "AUTHID" [ "CURRENT_USER" | "DEFINER" ]]
     [ "AS" | "IS" ]
     (
        typeDeclaration()
        | cursorDeclaration()
        | functionDeclaration()
        | procedureDeclaration()
        | pragmaDeclaration()
     )*
     "END" [ OracleObjectName() ] ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      PLSQLPackageNode packageNode = new PLSQLPackageNode();
      if (schema != null) {
        packageNode.setPackageName(schema + "." + packageName);      }      else {
        packageNode.setPackageName(packageName);      }
      ((PLSQLNode)jjtn000).setPackageNode(packageNode);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode typeDeclaration():
{/*@bgen(jjtree) typeDeclaration */
 PLSQLNode jjtn000 = new PLSQLNode(JJTTYPEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) typeDeclaration */
    try {
/*@egen*/
    "TYPE" t=<S_IDENTIFIER> "IS" 
        typeDeclarationBody()
    ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode cursorDeclaration():
{/*@bgen(jjtree) cursorDeclaration */
 PLSQLNode jjtn000 = new PLSQLNode(JJTCURSORDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) cursorDeclaration */
    try {
/*@egen*/
    "CURSOR" t=<S_IDENTIFIER>
    ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode functionDeclaration():
{/*@bgen(jjtree) functionDeclaration */
 PLSQLNode jjtn000 = new PLSQLNode(JJTFUNCTIONDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) functionDeclaration */
    try {
/*@egen*/
    "FUNCTION" t=<S_IDENTIFIER>
        functionDeclarationBody()
        "RETURN" <S_IDENTIFIER> [ "%TYPE" | "%ROWTYPE" ]
        [ "DETERMINISTIC" | "PIPELINED" | "PARALLEL_ENABLE" | "RESULT_CACHE" ]
    ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

SimpleNode procedureDeclaration():
{/*@bgen(jjtree) procedureDeclaration */
 PLSQLNode jjtn000 = new PLSQLNode(JJTPROCEDUREDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) procedureDeclaration */
    try {
/*@egen*/
    "PROCEDURE" t=<S_IDENTIFIER>
        procedureDeclarationBody()
    ";"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void pragmaDeclaration():
{/*@bgen(jjtree) pragmaDeclaration */
  PLSQLNode jjtn000 = new PLSQLNode(JJTPRAGMADECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) pragmaDeclaration */
    try {
/*@egen*/    "PRAGMA"
    [ "AUTONOMOUS_TRANSACTION"
    | "EXCEPTION_INIT" "(" <S_IDENTIFIER> "," < S_NUMBER> ")"
    | "SERIALLY_REUSABLE"
    | "INLINE" "(" <S_IDENTIFIER> "," [ "'YES'" | "'NO'" ] ")"
    | "RESTRICT_REFERENCES" "(" [ <S_IDENTIFIER> | "DEFAULT" ]
        ( "," [ "RNDS" | "WNDS" | "RNPS" | "WNPS" | "TRUST"] )+ ")"
    ]
    ";"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void typeDeclarationBody():
{/*@bgen(jjtree) typeDeclarationBody */
  PLSQLNode jjtn000 = new PLSQLNode(JJTTYPEDECLARATIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) typeDeclarationBody */
   try {
/*@egen*/
   < ~[] >
   ";"/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void functionDeclarationBody():
{/*@bgen(jjtree) functionDeclarationBody */
  PLSQLNode jjtn000 = new PLSQLNode(JJTFUNCTIONDECLARATIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) functionDeclarationBody */
   try {
/*@egen*/
   < ~[] >
   ";"/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void procedureDeclarationBody():
{/*@bgen(jjtree) procedureDeclarationBody */
  PLSQLNode jjtn000 = new PLSQLNode(JJTPROCEDUREDECLARATIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) procedureDeclarationBody */
   try {
/*@egen*/
   < ~[] >
   ";"/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}