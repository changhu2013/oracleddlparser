/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
options {
    MULTI = false;
    //STATIC = true;
    STATIC = false;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
    VISITOR = true;
    NODE_CLASS = "ParseNode";
    SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
    TRACK_TOKENS = true;
    //DEBUG_PARSER = true;
}
PARSER_BEGIN(DDLParser)
/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - add PLSQL package spec parsing to DBWSBuilder
 ******************************************************************************/
package org.eclipse.persistence.tools.dbws.metadata.parser;

//javase imports
import java.io.InputStream;
import java.util.Stack;

//metadata imports
import org.eclipse.persistence.tools.dbws.metadata.*;

@SuppressWarnings("unused")
public class DDLParser {

    protected Stack<DatabaseType> typeStack = new Stack<DatabaseType>();
    protected DatabaseTypesRepository typesRepository = new DatabaseTypesRepository();

    public DDLParser() {
        super();
    }

    public void setTypesRepository(DatabaseTypesRepository typesRepository) {
        this.typesRepository = typesRepository;
    }

    /*
    public static void main( String args[] ) throws ParseException {
        DDLParser p = null ;
        if (args.length < 1) {
            System.out.println("Reading from stdin") ;
            p = new DDLParser(System.in) ;
        }
        else {
            try {
                p = new DDLParser(new java.io.DataInputStream(
                                new java.io.FileInputStream(args[0]))) ;
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new DDLParser(System.in) ;
            }
        }
        SimpleNode sn = p.parsePLSQLPackage();
        sn.dump(">");
    }
    */
}

PARSER_END(DDLParser)

// white-space
SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}
// comments
SKIP: {
    <COMMENT_LINE: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}
SKIP:{
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// PLSQL keywords (NB: incomplete list)
TOKEN: {  
          <K_A: "A">
        | <K_ADD: "ADD">
        | <K_ALTER: "ALTER">
        | <K_ARRAY: "ARRAY">
        | <K_AS: "AS">
        | <K_AUTHID: "AUTHID">
        | <K_AUTOMATIC: "AUTOMATIC">
        | <K_AUTONOMOUS_TRANSACTION: "AUTONOMOUS_TRANSACTION">
        | <K_BEGIN: "BEGIN">
        | <K_BFILE: "BFILE">
        | <K_BINARY_DOUBLE: "BINARY_DOUBLE">
        | <K_BINARY_FLOAT: "BINARY_FLOAT">
        | <K_BINARY_INTEGER: "BINARY_INTEGER">
        | <K_BLOB: "BLOB">
        | <K_BODY: "BODY">
        | <K_BOOLEAN: "BOOLEAN">
        | <K_BUILTIN: "BUILTIN">
        | <K_BULK: "BULK">
        | <K_BY: "BY">
        | <K_BYTE: "BYTE">
        | <K_CHAR: "CHAR">
        | <K_CHARACTER: "CHARACTER">
        | <K_CHARSET: "%CHARSET">
        | <K_CLOB: "CLOB">
        | <K_CLOSE: "CLOSE">
        | <K_COLLECT: "COLLECT">
        | <K_COMMIT: "COMMIT">
        | <K_CONSTANT: "CONSTANT">
        | <K_CONSTRAINT: "CONSTRAINT">
        | <K_COUNT: "COUNT">
        | <K_CREATE: "CREATE">
        | <K_CROSS: "CROSS">
        | <K_CUBE: "CUBE">
        | <K_CURRENT_OF: "CURRENT_OF">
        | <K_CURRENT_USER: "CURRENT_USER">
        | <K_CURSOR: "CURSOR">
        | <K_DATE: "DATE">
        | <K_DAY: "DAY">
        | <K_DBTIMEZONE: "DBTIMEZONE">
        | <K_DEC: "DEC">
        | <K_DECIMAL: "DECIMAL">
        | <K_DECREMENT: "DECREMENT">
        | <K_DEFAULT: "DEFAULT">
        | <K_DEFINER: "DEFINER">
        | <K_DELETE: "DELETE">
        | <K_DETERMINISTIC: "DETERMINISTIC">
        | <K_DIMENSION: "DIMENSION">
        | <K_DOUBLE: "DOUBLE">
        | <K_ELSIF: "ELSIF">
        | <K_EMPTY: "EMPTY">
        | <K_ENABLE: "ENABLE">
        | <K_END: "END">
        | <K_EQUALS_PATH: "EQUALS_PATH">
        | <K_ESCAPE: "ESCAPE">
        | <K_EXCEPTION: "EXCEPTION">
        | <K_EXCEPTION_INIT: "EXCEPTION_INIT">
        | <K_EXIT: "EXIT">
        | <K_FALSE: "FALSE">
        | <K_FIPSFLAG: "FIPSFLAG">
        | <K_FIRST: "FIRST">
        | <K_FLOAT: "FLOAT">
        | <K_FULL: "FULL">
        | <K_FUNCTION: "FUNCTION">
        | <K_GLOBAL: "GLOBAL">
        | <K_GROUPING: "GROUPING">
        | <K_IGNORE: "IGNORE">
        | <K_IN: "IN">
        | <K_INCREMENT: "INCREMENT">
        | <K_INDEX: "INDEX">
        | <K_INFINITE: "INFINITE">
        | <K_INLINE: "INLINE">
        | <K_INNER: "INNER">
        | <K_INT: "INT">
        | <K_INTEGER: "INTEGER">
        | <K_INTERFACE: "INTERFACE">
        | <K_INTERVAL: "INTERVAL">
        | <K_IS: "IS">
        | <K_ITERATE: "ITERATE">
        | <K_JOIN: "JOIN">
        | <K_KEY: "KEY">
        | <K_KEEP: "KEEP">
        | <K_LAST: "LAST">
        | <K_LEFT: "LEFT">
        | <K_LIKE2: "LIKE2">
        | <K_LIKE4: "LIKE4">
        | <K_LIKEC: "LIKEC">
        | <K_LOCAL: "LOCAL">
        | <K_LONG: "LONG">
        | <K_LOOP: "LOOP">
        | <K_MAIN: "MAIN">
        | <K_MEASURES: "MEASURES">
        | <K_MEMBER: "MEMBER">
        | <K_MLSLABEL: "MLSLABEL">
        | <K_MODEL: "MODEL">
        | <K_MONTH: "MONTH">
        | <K_NAN: "NAN">
        | <K_NATIONAL: "NATIONAL">
        | <K_NATURAL: "NATURAL">
        | <K_NAV: "NAV">
        | <K_NCHAR: "NCHAR">
        | <K_NCLOB: "NCLOB">
        | <K_NEW_NAMES: "NEW_NAMES">
        | <K_NO: "'NO'">
        | <K_NOCYCLE: "NOCYCLE">
        | <K_NOCOPY: "NOCOPY">
        | <K_NOT: "NOT">
        | <K_NULL: "NULL">
        | <K_NULLS: "NULLS">
        | <K_NUMBER: "NUMBER">
        | <K_NUMERIC: "NUMERIC">
        | <K_NVARCHAR2: "NVARCHAR2">
        | <K_NVARCHAR: "NVARCHAR">
        | <K_OBJECT: "OBJECT">
        | <K_OF: "OF">
        | <K_ON: "ON">
        | <K_ONLY: "ONLY">
        | <K_OPEN: "OPEN">
        | <K_OR: "OR">
        | <K_OUT: "OUT">
        | <K_OUTER: "OUTER">
        | <K_PACKAGE: "PACKAGE">
        | <K_PARALLEL_ENABLE: "PARALLEL_ENABLE">
        | <K_PARTITION: "PARTITION">
        | <K_PIPELINED: "PIPELINED">
        | <K_PLS_INTEGER: "PLS_INTEGER">
        | <K_POSITIVE: "POSITIVE">
        | <K_PRAGMA: "PRAGMA">
        | <K_PRECISION: "PRECISION">
        | <K_PRESENT: "PRESENT">
        | <K_PRESERVE: "PRESERVE">
        | <K_PRIMARY: "PRIMARY">
        | <K_PROCEDURE: "PROCEDURE">
        | <K_RAISE: "RAISE">
        | <K_RANGE: "RANGE">
        | <K_RAW: "RAW">
        | <K_READ: "READ">
        | <K_REAL: "REAL">
        | <K_RECORD: "RECORD">
        | <K_REF: "REF">
        | <K_REFERENCE: "REFERENCE">
        | <K_REGEXP_LIKE: "REGEXP_LIKE">
        | <K_REPLACE: "REPLACE">
        | <K_RESTRICT_REFERENCES: "RESTRICT_REFERENCES">
        | <K_RESULT_CACHE: "RESULT_CACHE">
        | <K_RETURN: "RETURN">
        | <K_RETURNING: "RETURNING">
        | <K_REVERSE: "REVERSE">
        | <K_RIGHT: "RIGHT">
        | <K_RNDS: "RNDS">
        | <K_RNPS: "RNPS">
        | <K_ROLLBACK: "ROLLBACK">
        | <K_ROLLUP: "ROLLUP">
        | <K_ROWID: "ROWID">
        | <K_ROWS: "ROWS">
        | <K_ROWTYPE: "%ROWTYPE">
        | <K_RULES: "RULES">
        | <K_SECOND: "SECOND">
        | <K_SECONDS: "SECONDS">
        | <K_SEQUENTIAL: "SEQUENTIAL">
        | <K_SERIALLY_REUSABLE: "SERIALLY_REUSABLE">
        | <K_SESSIONTIMEZONE: "SESSIONTIMEZONE">
        | <K_SET: "SET">
        | <K_SETS: "SETS">
        | <K_SIBLINGS: "SIBLINGS">
        | <K_SINGLE: "SINGLE">
        | <K_SMALLINT: "SMALLINT">
        | <K_SOME: "SOME">
        | <K_STRING: "STRING">
        | <K_SUBMUlookISET: "SUBMUlookISET">
        | <K_SUBTYPE: "SUBTYPE">
        | <K_TABLE: "TABLE">
        | <K_TEMPORARY: "TEMPORARY">
        | <K_THE: "THE">
        | <K_TIME: "TIME">
        | <K_TIMESTAMP: "TIMESTAMP">
        | <K_TO: "TO">
        | <K_TRANSACTION: "TRANSACTION">
        | <K_TRUE: "TRUE">
        | <K_TRUST: "TRUST">
        | <K_TYPE: "TYPE">
        | <K_TYPE2: "%TYPE">
        | <K_UNDER_PATH: "UNDER_PATH">
        | <K_UNTIL: "UNTIL">
        | <K_UPDATED: "UPDATED">
        | <K_UPSERT: "UPSERT">
        | <K_UROWID: "UROWID">
        | <K_USING: "USING">
        | <K_VARCHAR2: "VARCHAR2">
        | <K_VARCHAR: "VARCHAR">
        | <K_VARRAY: "VARRAY">
        | <K_VARYING: "VARYING">
        | <K_WITH: "WITH">
        | <K_WHILE: "WHILE">
        | <K_WNDS: "WNDS">
        | <K_WNPS: "WNPS">
        | <K_WORK: "WORK">
        | <K_YEAR: "YEAR">
        | <K_YES: "'YES'">
        | <K_ZONE: "ZONE">
}

// operators
TOKEN: {
          <O_ASSIGN: ":=">
        | <O_ASTERISK: "*">
        | <O_ATSIGN: "@">
        | <O_CLOSEPAREN: ")">
        | <O_CONCAT: "||">
        | <O_COLON: ":">
        | <O_COMMA: ",">
        | <O_DOT: ".">
        | <O_DOUBLEDOT: "..">
        | <O_DOLLAR: "$">
        | <O_PERCENT: "%">
        | <O_EQUAL: "=">
        | <O_GREATER: ">">
        | <O_GREATEREQUAL: ">=">
        | <O_JOINPLUS: "(+)">
        | <O_LESS: "<">
        | <O_LESSEQUAL: "<=">
        | <O_MINUS: "-">
        | <O_NOTEQUAL2: "<>">
        | <O_NOTEQUAL: "!=">
        | <O_OPENPAREN: "(">
        | <O_PLUS: "+">
        | <O_POUND: "#">
        | <O_QUESTIONMARK: "?">
        | <O_SEMICOLON: ";">
        | <O_SLASH: "/">
        | <O_TILDE: "~">
}

// numeric literals
TOKEN : {
    <S_NUMBER: <FLOAT>
        | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
      >
    | <#FLOAT: <INTEGER>
            | <INTEGER> ( "." <INTEGER> )?
            | "." <INTEGER>
      >
    | <#INTEGER: ( <DIGIT> )+ >
    | <#DIGIT: ["0" - "9"] >
}

// identifiers
TOKEN:
{
    <S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> | <SPECIAL_CHARS>)* >
  | <#LETTER: ["a"-"z", "A"-"Z"] >
  | <#SPECIAL_CHARS: "$" | "_" | "#" | "@" >
  | <S_BIND: ":" ( <S_NUMBER> | <S_IDENTIFIER> ("." <S_IDENTIFIER>)?) >
  | <S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
  | <S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

// stripped-down version of PLSQL grammar: only parses package/top-level specifications

ParseNode parsePLSQLPackage():
{String schema = null;
 String packageName = null;}
{
    <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_PACKAGE>
        [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] packageName=OracleObjectName()
        {
          PLSQLPackageType packageType = new PLSQLPackageType();
          if (schema != null) {
            packageType.setPackageName(schema + "." + packageName);
          }
          else {
            packageType.setPackageName(packageName);
          }
          typeStack.push(packageType);
        }
        [ <K_AUTHID> [ <K_CURRENT_USER> | <K_DEFINER> ] ]
        [ <K_AS> | <K_IS> ]
         ( packageDeclaration() )*
     <K_END> [ packageName=OracleObjectName() ] <O_SEMICOLON>
     <EOF>
    {
      jjtThis.jjtSetValue(packageName);
      return jjtThis;
    }
}

// procedure at 'top-level'
ParseNode parseTopLevelProcedure():
{String schema = null;
 String procedureName = null;}
{
  <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_PROCEDURE>
    [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] procedureName=OracleObjectName()
    [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ] [ <K_AS> | <K_IS> ]
        skipToEnd()
    {
      StringBuilder sb = new StringBuilder("<TOPLEVEL> PROCEDURE ");
      if (schema != null) {
         sb.append(schema);
         sb.append(".");
         sb.append(procedureName);
      }
      else {
         sb.append(procedureName);
      }
      jjtThis.jjtSetValue(sb.toString());
      return jjtThis;
    }
}

// function at 'top-level'
ParseNode parseTopLevelFunction():
{String schema = null;
 String procedureName = null;}
{
  <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_FUNCTION>
    [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] procedureName=OracleObjectName()
    [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ] functionReturnSpec() [ <K_AS> | <K_IS> ]
        skipToEnd()
    {
      StringBuilder sb = new StringBuilder("<TOPLEVEL> FUNCTION ");
      if (schema != null) {
         sb.append(schema);
         sb.append(".");
         sb.append(procedureName);
      }
      else {
         sb.append(procedureName);
      }
      jjtThis.jjtSetValue(sb.toString());
      return jjtThis;
    }
}

// tables at 'top-level'
DatabaseType parseTable():
{TableType table = null;
 String schema = null;
 String tableName = null;}
{
    <K_CREATE> [ <K_GLOBAL> <K_TEMPORARY> ] <K_TABLE> 
        [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] tableName=OracleObjectName()
        {
            table = new TableType(tableName);
		    if (schema != null) {
		         table.setSchema(schema);
		    }
		    typeStack.push(table);        }
        <O_OPENPAREN> columnDeclarations() <O_CLOSEPAREN>
         [ <K_ON> <K_COMMIT > [<K_DELETE> | <K_PRESERVE> ] <K_ROWS> ]
         <O_SEMICOLON>
        ( alterDeclaration() <O_SEMICOLON> ) *
     <EOF>
     {
         return typeStack.pop();
     }
}

ParseNode alterDeclaration():
{String pk = null;
}
{
    <K_ALTER> <K_TABLE> columnSpec() <K_ADD> <K_PRIMARY> <K_KEY>
         <O_OPENPAREN> pk=OracleObjectName() <O_CLOSEPAREN> <K_ENABLE>
    {
      StringBuilder sb = new StringBuilder("PK=");
      if (pk != null) {
        sb.append(pk);
      }
      jjtThis.jjtSetValue(sb.toString());
      return jjtThis;
    }
}

// types at 'top-level'
ParseNode parseType():
{String schema = null;
 String typeName = null;
 boolean varray = false;
 boolean nestedTable = false;
}
{
    <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_TYPE>
      [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] typeName=OracleObjectName() <K_AS>
        [ <K_OBJECT> <O_OPENPAREN> columnDeclarations() <O_CLOSEPAREN>
          | <K_VARRAY> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> <K_OF> columnTypeSpec() { varray = true; }
          | <K_TABLE> <K_OF> columnTypeSpec() { nestedTable = true; }
        ] 
     [ <O_SEMICOLON> ]
     <EOF>
    {
      StringBuilder sb = new StringBuilder("TYPE ");
      if (schema != null) {
         sb.append(schema);
         sb.append(".");
         sb.append(typeName);
      }
      else {
         sb.append(typeName);
      }
      if (nestedTable) {
        sb.append(" TABLE OF ");
      }      else if (varray) {
        sb.append(" VARRAY OF ");
      }
      jjtThis.jjtSetValue(sb.toString());
      return jjtThis;
    }
}

void columnDeclarations() #void:
{}
{
    columnDeclaration() ( <O_COMMA> columnDeclaration() )*     
}

ParseNode columnDeclaration():
{String s = null;
 String pk = null;
 boolean notNull = false;
}
{
    {
        DatabaseType enclosingType = typeStack.peek();    }
    s=OracleObjectName()
        {
            if (enclosingType.isComplex()) {                FieldType column = new FieldType(s);
                ((ComplexDatabaseType)enclosingType).addEnclosedType(column);
                typeStack.push(column);
            }        }
        columnTypeSpec() [ <K_NOT> <K_NULL> <K_ENABLE> {notNull = true;} ]
    {
      
      if (enclosingType.isComplex()) {
          typeStack.pop();
      }
      StringBuilder sb = new StringBuilder();
      if (notNull) {
        sb.append("(NOT NULL)");
      }
      sb.append(s);
      jjtThis.jjtSetValue(sb.toString());
      return jjtThis;
    }
}

String columnTypeSpec():
{String s = null;}
{
    (
      datatype()
    | columnSpec() [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    )
    {
      Token first = jjtThis.jjtGetFirstToken();
      Token last = jjtThis.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder();
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);
      }
      jjtThis.jjtSetValue(sb.toString());
      return sb.toString();
    }
}

void packageDeclaration() #void:
{}
{
    LOOKAHEAD(2) variableDeclaration()
    | typeDeclaration()
    | cursorDeclaration()
    | procedureSpec()
    | functionSpec()
    | exceptionDeclaration()
    | pragmaDeclaration()
}

void variableDeclaration():
{}
{
    <S_IDENTIFIER> [ <K_CONSTANT> ] typeSpec() [ <K_NOT> <K_NULL> ]
        [ variableDefaultAssignment() ]
    <O_SEMICOLON>}

void variableDefaultAssignment() #void:
{}
{
    ( <O_ASSIGN> | <K_DEFAULT> ) skipToSemiColon()
}

void datatype() #void:
{Token t = null;
 Token precision = null;
 Token scale = null;}
{
    <K_BINARY_INTEGER>  { typeStack.push(UnsizedType.BINARY_INTEGER_TYPE);}
    | <K_BINARY_FLOAT>  { typeStack.push(UnsizedType.BINARY_FLOAT_TYPE);}
    | <K_BINARY_DOUBLE> { typeStack.push(UnsizedType.BINARY_DOUBLE_TYPE);}
    | <K_NATURAL>       { typeStack.push(UnsizedType.NATURAL_TYPE);}
    | <K_POSITIVE>      { typeStack.push(UnsizedType.POSITIVE_TYPE);}
    | ( t=<K_NUMBER>
        | t=<K_NUMERIC>
        | t=<K_DECIMAL>
        | t=<K_DEC>
      ) [ <O_OPENPAREN> precision=<S_NUMBER> ( <O_COMMA> scale=<S_NUMBER> )* <O_CLOSEPAREN> ]
        {
            DatabaseType dt = null;
            Long sl;
            Long pl;
            if (t.kind == K_NUMBER || t.kind == K_NUMERIC) {
                if (precision == null) {
                    dt = new NumericType();
                }
	            else {
	                pl = Long.decode(precision.image);
	                if (scale == null) {
                        dt = new NumericType(pl);
                    }
                    else {
                        sl = Long.decode(scale.image);
                        dt = new NumericType(pl, sl);
	                }
	            }
            }
            else  if (t.kind == K_DECIMAL || t.kind == K_DEC) {
                if (precision == null) {
                    dt = new DecimalType();
                }
                else {
                    pl = Long.decode(precision.image);
                    if (scale == null) {
                        dt = new DecimalType(pl);
                    }
                    else {
                        sl = Long.decode(scale.image);
                        dt = new DecimalType(pl, sl);
                    }
                }
            }            typeStack.push(dt);         }
    | <K_LONG> [ <K_RAW> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_RAW> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_BOOLEAN> { typeStack.push(UnsizedType.BOOLEAN_TYPE);}
    | <K_DATE> { typeStack.push(UnsizedType.DATE_TYPE);}
    | LOOKAHEAD(2) <K_INTERVAL> <K_DAY> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] <K_TO> <K_SECONDS> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_INTERVAL> <K_YEAR> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] <K_TO> <K_MONTH>
    | ( <K_TIME> { typeStack.push(UnsizedType.TIME_TYPE);}
        | <K_TIMESTAMP> { typeStack.push(UnsizedType.TIMESTAMP_TYPE);}
      ) [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] [ <K_WITH> [ <K_LOCAL> ] <K_TIME> <K_ZONE> ]
    | <K_INTEGER>  { typeStack.push(UnsizedType.INTEGER_TYPE);}
    | <K_INT>      { typeStack.push(UnsizedType.INTEGER_TYPE);}
    | <K_SMALLINT> { typeStack.push(UnsizedType.SMALLINT_TYPE);}
    | <K_FLOAT> [ <O_OPENPAREN> precision=<S_NUMBER> <O_CLOSEPAREN> ]
        {
          if (precision == null) {
              typeStack.push(new FloatType());
          }
          else {
           pl = Long.decode(precision.image);
           FloatType ft = new FloatType(pl);
           typeStack.push(ft);          }
        }
    | <K_REAL> { typeStack.push(new RealType());}
    | <K_MLSLABEL> { typeStack.push(UnsizedType.MLSLABEL_TYPE);}
    | <K_PLS_INTEGER> { typeStack.push(UnsizedType.PLS_INTEGER_TYPE);}
    | <K_BLOB > { typeStack.push(new BlobType());}
    | <K_NCLOB>
    | <K_BFILE>
    | <K_ROWID> { typeStack.push(UnsizedType.ROWID_TYPE);}
    | <K_UROWID> [ <O_OPENPAREN> precision=<S_NUMBER> <O_CLOSEPAREN> ]
        {
          if (precision == null) {
              typeStack.push(new URowIdType());
          }
          else {
              pl = Long.decode(precision.image);
              typeStack.push(new URowIdType(pl));
          }        }
    | <K_DOUBLE> <K_PRECISION> { typeStack.push(new DoubleType());}
    | <K_CHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
    | <K_VARCHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
    | <K_VARCHAR2> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
    | <K_CHARACTER> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NCHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NVARCHAR> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NVARCHAR2> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NATIONAL> ( <K_CHARACTER> | <K_CHAR> ) [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_CLOB> [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ] { typeStack.push(new ClobType());}
}

String typeSpec():
{String s = null;}
{
    (      datatype()
    | LOOKAHEAD(3) columnSpec() <K_TYPE2>
    | LOOKAHEAD(3) tableSpec() <K_ROWTYPE>
    | typeName() [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    )
    {
      Token first = jjtThis.jjtGetFirstToken();
      Token last = jjtThis.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder();
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);      }
      jjtThis.jjtSetValue(sb.toString());
      return sb.toString();    }
}

String columnSpec() #void:
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() [ <O_DOT> OracleObjectName() ] ]
    {return token.image;}
}

String tableSpec() #void:
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() [ <O_ATSIGN> <S_IDENTIFIER> ] ]
    {return token.image;}
}

String typeName() #void:
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() ]
    {return token.image;}
}

ParseNode typeDeclaration():
{String s = null;}
{
    <K_TYPE> s=typeName() <K_IS>
        aTypeDeclaration()
    <O_SEMICOLON>
    {
      jjtThis.jjtSetValue(s);
      return jjtThis;
    }
}

void aTypeDeclaration() #void:
{}
{
    recordDeclaration()
    | subtypeDeclaration()
    | plsqlTableDeclaration()
    | varrayDeclaration()
    | refCursorDeclaration()
}

ParseNode recordDeclaration():
{}
{
    <K_RECORD> <O_OPENPAREN>
        fieldDeclarations()
    <O_CLOSEPAREN>
    { jjtThis.jjtSetValue("RECORD");
      return jjtThis; }
}

void fieldDeclarations() #void:
{}
{
    fieldDeclaration() ( <O_COMMA> fieldDeclaration() )*
}

ParseNode fieldDeclaration():
{String s = null;
}
{
    s=typeName() typeSpec() [ <K_NOT> <K_NULL> ] [ variableDefaultAssignment() ]
    {
      jjtThis.jjtSetValue(s);
      return jjtThis;
    }
}

ParseNode subtypeDeclaration():
{}
{
    <K_SUBTYPE> OracleObjectName() <K_IS> datatype()
        ( <K_RANGE> <S_NUMBER> <O_DOUBLEDOT> <S_NUMBER>
        | <S_NUMBER> [ <O_COMMA> <S_NUMBER> ]
        | <K_CHARACTER> <K_SET> <S_IDENTIFIER>
        ) [ <K_NOT> <K_NULL> ]
    { return jjtThis; }
}

ParseNode plsqlTableDeclaration():
{}
{
    <K_TABLE> <K_OF> typeSpec() [ <K_NOT> <K_NULL> ] <K_INDEX> <K_BY>
        plsqlTableIndexByDeclaration()
    {
      jjtThis.jjtSetValue("TABLE OF");
      return jjtThis;
    }
}

ParseNode plsqlTableIndexByDeclaration():
{}
{
    ( <K_PLS_INTEGER >
    | <K_BINARY_INTEGER>
    | <K_VARCHAR2> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
    | <K_STRING> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
    )
    {
      Token first = jjtThis.jjtGetFirstToken();
      Token last = jjtThis.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder("INDEX BY ");
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);
      }
      jjtThis.jjtSetValue(sb.toString());
      return jjtThis;
    }
}

ParseNode varrayDeclaration():
{}
{
    ( <K_VARRAY> | <K_VARYING> <K_ARRAY> ) <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
        <K_OF> datatype() [ <K_NOT> <K_NULL> ]
    { return jjtThis; }
}

ParseNode refCursorDeclaration():
{String s = null;}
{
    <K_REF> <K_CURSOR> [ refCursorTypeSpec() ]
    {
      jjtThis.jjtSetValue("REF CURSOR");
      return jjtThis;
    }
}

ParseNode refCursorTypeSpec():
{String s = null;}
{
    <K_RETURN> [LOOKAHEAD(3) s=columnSpec() [ <K_TYPE2> ]
    | LOOKAHEAD(3) s=tableSpec() [ <K_ROWTYPE> ] ]
    {
      jjtThis.jjtSetValue("RETURN " +s);
      return jjtThis;
    }
}

ParseNode cursorDeclaration():
{Token t = null;}
{
    <K_CURSOR> t=<S_IDENTIFIER>
    <O_SEMICOLON>
    {
      jjtThis.jjtSetValue(t.image);
      return jjtThis;
    }
}

// Procedure Specification
ParseNode procedureSpec():
{Token t = null;}
{
    <K_PROCEDURE> t=<S_IDENTIFIER>
        [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ]
    <O_SEMICOLON>
    {
      jjtThis.jjtSetValue("PROCEDURE " + t.image);
      return jjtThis;
    }
}

void argumentList() #void:
{}
{
   argument() ( <O_COMMA> argument() )*
}

// Function Specification
ParseNode functionSpec():
{Token t = null;}
{
    <K_FUNCTION> t=<S_IDENTIFIER>
        [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ]
        functionReturnSpec()
        [ <K_DETERMINISTIC> | <K_PIPELINED> | <K_PARALLEL_ENABLE> | <K_RESULT_CACHE> ]
    <O_SEMICOLON>
    {
      jjtThis.jjtSetValue("FUNCTION " + t.image);
      return jjtThis;
    }
}

ParseNode functionReturnSpec():
{}{    (<K_RETURN> typeSpec())
    {
      jjtThis.jjtSetValue("RETURN");
      return jjtThis;
    }
}

ParseNode argument():
{Token t = null;
 String direction = null;
}
{
    t=<S_IDENTIFIER> [(direction=direction())]
        [ <K_NOCOPY> ] typeSpec() [ argumentDefaultAssignment() ]
    {
      if (direction != null) {
          jjtThis.jjtSetValue(direction + " " + t.image);
      }
      else {
          // by default, arguments are IN
          jjtThis.jjtSetValue("IN " + t.image);
      }
      return jjtThis;
    }
}

String direction() #void:
{}
{
    LOOKAHEAD(2) <K_IN> <K_OUT> { return "IN OUT"; }
    | <K_IN> { return "IN"; }
    | <K_OUT>  { return "OUT"; }
}

ParseNode argumentDefaultAssignment():
{}
{
    ( <O_ASSIGN> | <K_DEFAULT> ) skipToNextArg()
    {
      jjtThis.jjtSetValue(" (optional)");
      return jjtThis;
    }
}

void exceptionDeclaration() #void:
{}
{
    <S_IDENTIFIER> <K_EXCEPTION>
    <O_SEMICOLON>
}

void pragmaDeclaration() #void:
{}
{    <K_PRAGMA>
    [ <K_AUTONOMOUS_TRANSACTION>
    | <K_EXCEPTION_INIT> <O_OPENPAREN> <S_IDENTIFIER> <O_COMMA> <S_NUMBER> <O_CLOSEPAREN>
    | <K_SERIALLY_REUSABLE>
    | <K_INLINE> <O_OPENPAREN> <S_IDENTIFIER> <O_COMMA> [ <K_YES> | <K_NO> ] <O_CLOSEPAREN>
    | <K_RESTRICT_REFERENCES> <O_OPENPAREN> [ <S_IDENTIFIER> | <K_DEFAULT> ]
        ( <O_COMMA> [ <K_RNDS> | <K_WNDS> | <K_RNPS> | <K_WNPS> | <K_TRUST>] )+ <O_CLOSEPAREN>
    ]
    <O_SEMICOLON>
}

String OracleObjectName() #void:
{}
{
    <S_IDENTIFIER>
    {return token.image;}
  | <S_QUOTED_IDENTIFIER>
    {
      String s = token.image;
      return s.substring(1, s.length() - 1); // strip-off quotes
    }
}

void skipToSemiColon() #void:
{}
{
    {
        Token t = getNextToken();
        while (t.kind != O_SEMICOLON) {
	        t = getNextToken();
        }
        token_source.input_stream.backup(1);
    }
}

void skipToNextArg() #void:
{}
{
    {
        Token t = getNextToken();
        while (t.kind != O_COMMA && t.kind != O_CLOSEPAREN) {
            t = getNextToken();
        }
        token_source.input_stream.backup(1);
    }
}

void skipToEnd() #void:
{}
{
    {
      /** skip through all the tokens. */
      Token t = getNextToken();
      while (t.kind != EOF) {
          t = getNextToken();
      }
  }

}