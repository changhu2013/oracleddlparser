/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. DDLParser.jj */
/*@egen*//*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - June 10 2011, created DDL parser package
 ******************************************************************************/
options {
                  
    //STATIC = true;
    STATIC = false;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
                   
                             
    SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
                        
    //DEBUG_PARSER = true;
}
PARSER_BEGIN(DDLParser)
/*******************************************************************************
 * Copyright (c) 2011 Oracle. All rights reserved.
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 and Eclipse Distribution License v. 1.0
 * which accompanies this distribution.
 * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 * http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *     Mike Norman - June 10 2011, created DDL parser package
 ******************************************************************************/
package org.eclipse.persistence.tools.dbws.metadata.parser;

//javase imports
import java.io.InputStream;
import java.util.Stack;

//metadata imports
import org.eclipse.persistence.tools.dbws.metadata.BlobType;
import org.eclipse.persistence.tools.dbws.metadata.ClobType;
import org.eclipse.persistence.tools.dbws.metadata.ComplexDatabaseType;
import org.eclipse.persistence.tools.dbws.metadata.DatabaseType;
import org.eclipse.persistence.tools.dbws.metadata.DatabaseTypesRepository;
import org.eclipse.persistence.tools.dbws.metadata.DecimalType;
import org.eclipse.persistence.tools.dbws.metadata.DoubleType;
import org.eclipse.persistence.tools.dbws.metadata.FieldType;
import org.eclipse.persistence.tools.dbws.metadata.FloatType;
import org.eclipse.persistence.tools.dbws.metadata.LongType;
import org.eclipse.persistence.tools.dbws.metadata.LongRawType;
import org.eclipse.persistence.tools.dbws.metadata.NumericType;
import org.eclipse.persistence.tools.dbws.metadata.PLSQLPackageType;
import org.eclipse.persistence.tools.dbws.metadata.RawType;
import org.eclipse.persistence.tools.dbws.metadata.RealType;
import org.eclipse.persistence.tools.dbws.metadata.TableType;
import org.eclipse.persistence.tools.dbws.metadata.URowIdType;
import org.eclipse.persistence.tools.dbws.metadata.UnresolvedSizedType;
import org.eclipse.persistence.tools.dbws.metadata.UnresolvedType;
import org.eclipse.persistence.tools.dbws.metadata.VarChar2Type;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.BINARY_INTEGER_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.BINARY_FLOAT_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.BINARY_DOUBLE_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.BOOLEAN_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.DATE_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.INTEGER_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.MLSLABEL_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.NATURAL_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.PLS_INTEGER_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.POSITIVE_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.ROWID_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.SMALLINT_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.TIME_TYPE;
import static org.eclipse.persistence.tools.dbws.metadata.ScalarType.TIMESTAMP_TYPE;

public class DDLParser/*@bgen(jjtree)*/implements DDLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTDDLParserState jjtree = new JJTDDLParserState();

/*@egen*/

    protected Stack<DatabaseType> typeStack = new Stack<DatabaseType>();
    protected DatabaseTypesRepository typesRepository = new DatabaseTypesRepository();

    public DDLParser() {
        super();
    }

    public void setTypesRepository(DatabaseTypesRepository typesRepository) {
        this.typesRepository = typesRepository;
    }

    /*
    public static void main( String args[] ) throws ParseException {
        DDLParser p = null ;
        if (args.length < 1) {
            System.out.println("Reading from stdin") ;
            p = new DDLParser(System.in) ;
        }
        else {
            try {
                p = new DDLParser(new java.io.DataInputStream(
                                new java.io.FileInputStream(args[0]))) ;
            }
            catch (java.io.FileNotFoundException e) {
                System.out.println("File " + args[0] +
                                " not found. Reading from stdin") ;
                p = new DDLParser(System.in) ;
            }
        }
        SimpleNode sn = p.parsePLSQLPackage();
        sn.dump(">");
    }
    */
}

PARSER_END(DDLParser)

// white-space
SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}
// comments
SKIP: {
    <COMMENT_LINE: "--" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}
SKIP:{
    <COMMENT_BLOCK: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

// PLSQL keywords (NB: incomplete list)
TOKEN: {  
          <K_A: "A">
        | <K_ADD: "ADD">
        | <K_ALTER: "ALTER">
        | <K_ARRAY: "ARRAY">
        | <K_AS: "AS">
        | <K_AUTHID: "AUTHID">
        | <K_AUTOMATIC: "AUTOMATIC">
        | <K_AUTONOMOUS_TRANSACTION: "AUTONOMOUS_TRANSACTION">
        | <K_BEGIN: "BEGIN">
        | <K_BFILE: "BFILE">
        | <K_BINARY_DOUBLE: "BINARY_DOUBLE">
        | <K_BINARY_FLOAT: "BINARY_FLOAT">
        | <K_BINARY_INTEGER: "BINARY_INTEGER">
        | <K_BLOB: "BLOB">
        | <K_BODY: "BODY">
        | <K_BOOLEAN: "BOOLEAN">
        | <K_BUILTIN: "BUILTIN">
        | <K_BULK: "BULK">
        | <K_BY: "BY">
        | <K_BYTE: "BYTE">
        | <K_CHAR: "CHAR">
        | <K_CHARACTER: "CHARACTER">
        | <K_CHARSET: "%CHARSET">
        | <K_CLOB: "CLOB">
        | <K_CLOSE: "CLOSE">
        | <K_COLLECT: "COLLECT">
        | <K_COMMIT: "COMMIT">
        | <K_CONSTANT: "CONSTANT">
        | <K_CONSTRAINT: "CONSTRAINT">
        | <K_COUNT: "COUNT">
        | <K_CREATE: "CREATE">
        | <K_CROSS: "CROSS">
        | <K_CUBE: "CUBE">
        | <K_CURRENT_OF: "CURRENT_OF">
        | <K_CURRENT_USER: "CURRENT_USER">
        | <K_CURSOR: "CURSOR">
        | <K_DATE: "DATE">
        | <K_DAY: "DAY">
        | <K_DBTIMEZONE: "DBTIMEZONE">
        | <K_DEC: "DEC">
        | <K_DECIMAL: "DECIMAL">
        | <K_DECREMENT: "DECREMENT">
        | <K_DEFAULT: "DEFAULT">
        | <K_DEFINER: "DEFINER">
        | <K_DELETE: "DELETE">
        | <K_DETERMINISTIC: "DETERMINISTIC">
        | <K_DIMENSION: "DIMENSION">
        | <K_DOUBLE: "DOUBLE">
        | <K_ELSIF: "ELSIF">
        | <K_EMPTY: "EMPTY">
        | <K_ENABLE: "ENABLE">
        | <K_END: "END">
        | <K_EQUALS_PATH: "EQUALS_PATH">
        | <K_ESCAPE: "ESCAPE">
        | <K_EXCEPTION: "EXCEPTION">
        | <K_EXCEPTION_INIT: "EXCEPTION_INIT">
        | <K_EXIT: "EXIT">
        | <K_FALSE: "FALSE">
        | <K_FIPSFLAG: "FIPSFLAG">
        | <K_FIRST: "FIRST">
        | <K_FLOAT: "FLOAT">
        | <K_FULL: "FULL">
        | <K_FUNCTION: "FUNCTION">
        | <K_GLOBAL: "GLOBAL">
        | <K_GROUPING: "GROUPING">
        | <K_IGNORE: "IGNORE">
        | <K_IN: "IN">
        | <K_INCREMENT: "INCREMENT">
        | <K_INDEX: "INDEX">
        | <K_INFINITE: "INFINITE">
        | <K_INLINE: "INLINE">
        | <K_INNER: "INNER">
        | <K_INT: "INT">
        | <K_INTEGER: "INTEGER">
        | <K_INTERFACE: "INTERFACE">
        | <K_INTERVAL: "INTERVAL">
        | <K_IS: "IS">
        | <K_ITERATE: "ITERATE">
        | <K_JOIN: "JOIN">
        | <K_KEY: "KEY">
        | <K_KEEP: "KEEP">
        | <K_LAST: "LAST">
        | <K_LEFT: "LEFT">
        | <K_LIKE2: "LIKE2">
        | <K_LIKE4: "LIKE4">
        | <K_LIKEC: "LIKEC">
        | <K_LOCAL: "LOCAL">
        | <K_LONG: "LONG">
        | <K_LOOP: "LOOP">
        | <K_MAIN: "MAIN">
        | <K_MEASURES: "MEASURES">
        | <K_MEMBER: "MEMBER">
        | <K_MLSLABEL: "MLSLABEL">
        | <K_MODEL: "MODEL">
        | <K_MONTH: "MONTH">
        | <K_NAN: "NAN">
        | <K_NATIONAL: "NATIONAL">
        | <K_NATURAL: "NATURAL">
        | <K_NAV: "NAV">
        | <K_NCHAR: "NCHAR">
        | <K_NCLOB: "NCLOB">
        | <K_NEW_NAMES: "NEW_NAMES">
        | <K_NO: "'NO'">
        | <K_NOCYCLE: "NOCYCLE">
        | <K_NOCOPY: "NOCOPY">
        | <K_NOT: "NOT">
        | <K_NULL: "NULL">
        | <K_NULLS: "NULLS">
        | <K_NUMBER: "NUMBER">
        | <K_NUMERIC: "NUMERIC">
        | <K_NVARCHAR2: "NVARCHAR2">
        | <K_NVARCHAR: "NVARCHAR">
        | <K_OBJECT: "OBJECT">
        | <K_OF: "OF">
        | <K_ON: "ON">
        | <K_ONLY: "ONLY">
        | <K_OPEN: "OPEN">
        | <K_OR: "OR">
        | <K_OUT: "OUT">
        | <K_OUTER: "OUTER">
        | <K_PACKAGE: "PACKAGE">
        | <K_PARALLEL_ENABLE: "PARALLEL_ENABLE">
        | <K_PARTITION: "PARTITION">
        | <K_PIPELINED: "PIPELINED">
        | <K_PLS_INTEGER: "PLS_INTEGER">
        | <K_POSITIVE: "POSITIVE">
        | <K_PRAGMA: "PRAGMA">
        | <K_PRECISION: "PRECISION">
        | <K_PRESENT: "PRESENT">
        | <K_PRESERVE: "PRESERVE">
        | <K_PRIMARY: "PRIMARY">
        | <K_PROCEDURE: "PROCEDURE">
        | <K_RAISE: "RAISE">
        | <K_RANGE: "RANGE">
        | <K_RAW: "RAW">
        | <K_READ: "READ">
        | <K_REAL: "REAL">
        | <K_RECORD: "RECORD">
        | <K_REF: "REF">
        | <K_REFERENCE: "REFERENCE">
        | <K_REGEXP_LIKE: "REGEXP_LIKE">
        | <K_REPLACE: "REPLACE">
        | <K_RESTRICT_REFERENCES: "RESTRICT_REFERENCES">
        | <K_RESULT_CACHE: "RESULT_CACHE">
        | <K_RETURN: "RETURN">
        | <K_RETURNING: "RETURNING">
        | <K_REVERSE: "REVERSE">
        | <K_RIGHT: "RIGHT">
        | <K_RNDS: "RNDS">
        | <K_RNPS: "RNPS">
        | <K_ROLLBACK: "ROLLBACK">
        | <K_ROLLUP: "ROLLUP">
        | <K_ROWID: "ROWID">
        | <K_ROWS: "ROWS">
        | <K_ROWTYPE: "%ROWTYPE">
        | <K_RULES: "RULES">
        | <K_SECOND: "SECOND">
        | <K_SECONDS: "SECONDS">
        | <K_SEQUENTIAL: "SEQUENTIAL">
        | <K_SERIALLY_REUSABLE: "SERIALLY_REUSABLE">
        | <K_SESSIONTIMEZONE: "SESSIONTIMEZONE">
        | <K_SET: "SET">
        | <K_SETS: "SETS">
        | <K_SIBLINGS: "SIBLINGS">
        | <K_SINGLE: "SINGLE">
        | <K_SMALLINT: "SMALLINT">
        | <K_SOME: "SOME">
        | <K_STRING: "STRING">
        | <K_SUBMUlookISET: "SUBMUlookISET">
        | <K_SUBTYPE: "SUBTYPE">
        | <K_TABLE: "TABLE">
        | <K_TEMPORARY: "TEMPORARY">
        | <K_THE: "THE">
        | <K_TIME: "TIME">
        | <K_TIMESTAMP: "TIMESTAMP">
        | <K_TO: "TO">
        | <K_TRANSACTION: "TRANSACTION">
        | <K_TRUE: "TRUE">
        | <K_TRUST: "TRUST">
        | <K_TYPE: "TYPE">
        | <K_TYPE2: "%TYPE">
        | <K_UNDER_PATH: "UNDER_PATH">
        | <K_UNTIL: "UNTIL">
        | <K_UPDATED: "UPDATED">
        | <K_UPSERT: "UPSERT">
        | <K_UROWID: "UROWID">
        | <K_USING: "USING">
        | <K_VARCHAR2: "VARCHAR2">
        | <K_VARCHAR: "VARCHAR">
        | <K_VARRAY: "VARRAY">
        | <K_VARYING: "VARYING">
        | <K_WITH: "WITH">
        | <K_WHILE: "WHILE">
        | <K_WNDS: "WNDS">
        | <K_WNPS: "WNPS">
        | <K_WORK: "WORK">
        | <K_YEAR: "YEAR">
        | <K_YES: "'YES'">
        | <K_ZONE: "ZONE">
}

// operators
TOKEN: {
          <O_ASSIGN: ":=">
        | <O_ASTERISK: "*">
        | <O_ATSIGN: "@">
        | <O_CLOSEPAREN: ")">
        | <O_CONCAT: "||">
        | <O_COLON: ":">
        | <O_COMMA: ",">
        | <O_DOT: ".">
        | <O_DOUBLEDOT: "..">
        | <O_DOLLAR: "$">
        | <O_PERCENT: "%">
        | <O_EQUAL: "=">
        | <O_GREATER: ">">
        | <O_GREATEREQUAL: ">=">
        | <O_JOINPLUS: "(+)">
        | <O_LESS: "<">
        | <O_LESSEQUAL: "<=">
        | <O_MINUS: "-">
        | <O_NOTEQUAL2: "<>">
        | <O_NOTEQUAL: "!=">
        | <O_OPENPAREN: "(">
        | <O_PLUS: "+">
        | <O_POUND: "#">
        | <O_QUESTIONMARK: "?">
        | <O_SEMICOLON: ";">
        | <O_SLASH: "/">
        | <O_TILDE: "~">
}

// numeric literals
TOKEN : {
    <S_NUMBER: <FLOAT>
        | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
      >
    | <#FLOAT: <INTEGER>
            | <INTEGER> ( "." <INTEGER> )?
            | "." <INTEGER>
      >
    | <#INTEGER: ( <DIGIT> )+ >
    | <#DIGIT: ["0" - "9"] >
}

// identifiers
TOKEN:
{
    <S_IDENTIFIER: (<LETTER>)+ (<DIGIT> | <LETTER> | <SPECIAL_CHARS>)* >
  | <#LETTER: ["a"-"z", "A"-"Z"] >
  | <#SPECIAL_CHARS: "$" | "_" | "#" | "@" >
  | <S_BIND: ":" ( <S_NUMBER> | <S_IDENTIFIER> ("." <S_IDENTIFIER>)?) >
  | <S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
  | <S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

// stripped-down version of PLSQL grammar: only parses package/top-level specifications

ParseNode parsePLSQLPackage():
{/*@bgen(jjtree) parsePLSQLPackage */
 ParseNode jjtn000 = new ParseNode(JJTPARSEPLSQLPACKAGE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String schema = null;
 String packageName = null;}
{/*@bgen(jjtree) parsePLSQLPackage */
    try {
/*@egen*/
    <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_PACKAGE>
        [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] packageName=OracleObjectName()
        {
          PLSQLPackageType packageType = new PLSQLPackageType();
          if (schema != null) {
            packageType.setPackageName(schema + "." + packageName);
          }
          else {
            packageType.setPackageName(packageName);
          }
          typeStack.push(packageType);
        }
        [ <K_AUTHID> [ <K_CURRENT_USER> | <K_DEFINER> ] ]
        [ <K_AS> | <K_IS> ]
         ( packageDeclaration() )*
     <K_END> [ packageName=OracleObjectName() ] <O_SEMICOLON>
     <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      typeStack.pop();
      jjtn000.jjtSetValue(packageName);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

// procedure at 'top-level'
ParseNode parseTopLevelProcedure():
{/*@bgen(jjtree) parseTopLevelProcedure */
 ParseNode jjtn000 = new ParseNode(JJTPARSETOPLEVELPROCEDURE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String schema = null;
 String procedureName = null;}
{/*@bgen(jjtree) parseTopLevelProcedure */
  try {
/*@egen*/
  <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_PROCEDURE>
    [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] procedureName=OracleObjectName()
    [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ] [ <K_AS> | <K_IS> ]
        skipToEnd()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      StringBuilder sb = new StringBuilder("<TOPLEVEL> PROCEDURE ");
      if (schema != null) {
         sb.append(schema);
         sb.append(".");
         sb.append(procedureName);
      }
      else {
         sb.append(procedureName);
      }
      jjtn000.jjtSetValue(sb.toString());
      return jjtn000;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

// function at 'top-level'
ParseNode parseTopLevelFunction():
{/*@bgen(jjtree) parseTopLevelFunction */
 ParseNode jjtn000 = new ParseNode(JJTPARSETOPLEVELFUNCTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String schema = null;
 String procedureName = null;}
{/*@bgen(jjtree) parseTopLevelFunction */
  try {
/*@egen*/
  <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_FUNCTION>
    [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] procedureName=OracleObjectName()
    [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ] functionReturnSpec() [ <K_AS> | <K_IS> ]
        skipToEnd()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      StringBuilder sb = new StringBuilder("<TOPLEVEL> FUNCTION ");
      if (schema != null) {
         sb.append(schema);
         sb.append(".");
         sb.append(procedureName);
      }
      else {
         sb.append(procedureName);
      }
      jjtn000.jjtSetValue(sb.toString());
      return jjtn000;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

// tables at 'top-level'
DatabaseType parseTable():
{/*@bgen(jjtree) parseTable */
 ParseNode jjtn000 = new ParseNode(JJTPARSETABLE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/TableType table = null;
 String schema = null;
 String tableName = null;}
{/*@bgen(jjtree) parseTable */
    try {
/*@egen*/
    <K_CREATE> [ <K_GLOBAL> <K_TEMPORARY> ] <K_TABLE> 
        [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] tableName=OracleObjectName()
        {
            table = new TableType(tableName);
		    if (schema != null) {
		         table.setSchema(schema);
		    }
		    typeStack.push(table);        }
        <O_OPENPAREN> columnDeclarations() <O_CLOSEPAREN>
         [ <K_ON> <K_COMMIT > [<K_DELETE> | <K_PRESERVE> ] <K_ROWS> ] <O_SEMICOLON>
        ( alterDeclaration() <O_SEMICOLON> ) *
     <EOF>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
       jjtn000.jjtSetLastToken(getToken(0));
     }
/*@egen*/
     {
         return typeStack.pop();
     }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode alterDeclaration():
{/*@bgen(jjtree) alterDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTALTERDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) alterDeclaration */
    try {
/*@egen*/
    <K_ALTER> <K_TABLE> columnSpec() <K_ADD> [ <K_CONSTRAINT> OracleObjectName() ] <K_PRIMARY> <K_KEY>
      <O_OPENPAREN> OracleObjectName() ( <O_COMMA> OracleObjectName() )* <O_CLOSEPAREN> <K_ENABLE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      TableType table = (TableType)typeStack.peek();
      Token first = jjtn000.jjtGetFirstToken();
      Token last = jjtn000.jjtGetLastToken();
      Token cur = first;
      while (cur.kind != O_OPENPAREN) {
          cur = cur.next;
      }
      cur = cur.next;
      while (cur.kind != O_CLOSEPAREN) {
        if (cur.kind == O_COMMA) {
            cur = cur.next;
            continue;        }
        String str = cur.image;
        if (str.startsWith("\"")) {
          str = str.substring(1, str.length());
        }
        if (str.endsWith("\"")) {
          str = str.substring(0, str.length() - 1);
        }
        for (FieldType col : table.getColumns()) {
          if (col.getFieldName().equals(str)) {
              col.setPk();
              break;
          }         }
        cur = cur.next;
      }
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

// types at 'top-level'
ParseNode parseType():
{/*@bgen(jjtree) parseType */
 ParseNode jjtn000 = new ParseNode(JJTPARSETYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String schema = null;
 String typeName = null;
 boolean varray = false;
 boolean nestedTable = false;
}
{/*@bgen(jjtree) parseType */
    try {
/*@egen*/
    <K_CREATE> [ <K_OR> <K_REPLACE> ] <K_TYPE>
      [LOOKAHEAD(2) schema=OracleObjectName() <O_DOT> ] typeName=OracleObjectName() <K_AS>
        [ <K_OBJECT> <O_OPENPAREN> columnDeclarations() <O_CLOSEPAREN>
          | <K_VARRAY> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> <K_OF> columnTypeSpec() { varray = true; }
          | <K_TABLE> <K_OF> columnTypeSpec() { nestedTable = true; }
        ] 
     [ <O_SEMICOLON> ]
     <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      StringBuilder sb = new StringBuilder("TYPE ");
      if (schema != null) {
         sb.append(schema);
         sb.append(".");
         sb.append(typeName);
      }
      else {
         sb.append(typeName);
      }
      if (nestedTable) {
        sb.append(" TABLE OF ");
      }      else if (varray) {
        sb.append(" VARRAY OF ");
      }
      jjtn000.jjtSetValue(sb.toString());
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void columnDeclarations()      :
{}
{
    columnDeclaration() ( <O_COMMA> columnDeclaration() )*     
}

ParseNode columnDeclaration():
{/*@bgen(jjtree) columnDeclaration */
 ParseNode jjtn000 = new ParseNode(JJTCOLUMNDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;
 String pk = null;
 boolean notNull = false;
}
{/*@bgen(jjtree) columnDeclaration */
    try {
/*@egen*/
    {
        DatabaseType enclosingType = typeStack.peek();    }
    s=OracleObjectName()
        {
            if (enclosingType.isComplex()) {                FieldType column = new FieldType(s);
                ((ComplexDatabaseType)enclosingType).addEnclosedType(column);
                typeStack.push(column);
            }        }
        columnTypeSpec() [ <K_NOT> <K_NULL> <K_ENABLE> {notNull = true;} ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      
      if (enclosingType.isComplex()) {
          DatabaseType columnType = typeStack.pop();
          FieldType column = (FieldType)typeStack.pop();
          column.setDataType(columnType);
          if (notNull) {
              column.setNotNull();
          }
      }
      StringBuilder sb = new StringBuilder();
      if (notNull) {
        sb.append("(NOT NULL)");
      }
      sb.append(s);
      jjtn000.jjtSetValue(sb.toString());
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

String columnTypeSpec():
{/*@bgen(jjtree) columnTypeSpec */
 ParseNode jjtn000 = new ParseNode(JJTCOLUMNTYPESPEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;
 Token t = null;}
{/*@bgen(jjtree) columnTypeSpec */
    try {
/*@egen*/
    (
      datatype()
    | s=columnSpec() [ <O_OPENPAREN> t=<S_NUMBER> <O_CLOSEPAREN> ]
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      if (s != null) {
          DatabaseType dt = null;
          if (t != null) {
              Long size = Long.decode(t.image);
              dt = new UnresolvedSizedType(s, size);
          }
          else {
              dt = new UnresolvedType(s);
          }
          typeStack.push(dt);
          return dt.toString();
      } 
      Token first = jjtn000.jjtGetFirstToken();
      Token last = jjtn000.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder();
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);
      }
      jjtn000.jjtSetValue(sb.toString());
      return sb.toString();
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void packageDeclaration()      :
{}
{
    LOOKAHEAD(2) variableDeclaration()
    | typeDeclaration()
    | cursorDeclaration()
    | procedureSpec()
    | functionSpec()
    | exceptionDeclaration()
    | pragmaDeclaration()
}

void variableDeclaration():
{/*@bgen(jjtree) variableDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTVARIABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) variableDeclaration */
    try {
/*@egen*/
    <S_IDENTIFIER> [ <K_CONSTANT> ] typeSpec() [ <K_NOT> <K_NULL> ]
        [ variableDefaultAssignment() ]
    <O_SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/}

void variableDefaultAssignment()      :
{}
{
    ( <O_ASSIGN> | <K_DEFAULT> ) skipToSemiColon()
}

void datatype()      :
{Token t = null;
 DatabaseType dt = null;
 Token precision = null;
 Long sl;
 Long pl;
 Token scale = null;}
{
    <K_BINARY_INTEGER>  { typeStack.push(BINARY_INTEGER_TYPE);}
    | <K_BINARY_FLOAT>  { typeStack.push(BINARY_FLOAT_TYPE);}
    | <K_BINARY_DOUBLE> { typeStack.push(BINARY_DOUBLE_TYPE);}
    | <K_NATURAL>       { typeStack.push(NATURAL_TYPE);}
    | <K_POSITIVE>      { typeStack.push(POSITIVE_TYPE);}
    | ( t=<K_NUMBER>
        | t=<K_NUMERIC>
        | t=<K_DECIMAL>
        | t=<K_DEC>
      ) [ <O_OPENPAREN> [ precision=<O_ASTERISK > | precision=<S_NUMBER> ] ( <O_COMMA> scale=<S_NUMBER> )* <O_CLOSEPAREN> ]
        {
            if (t.kind == K_NUMBER || t.kind == K_NUMERIC) {
                if (precision != null && precision.image.equals("*")) {
                    precision = null;                }
                if (precision == null) {
                    dt = new NumericType();
                }
	            else {
	                pl = Long.decode(precision.image);
	                if (scale == null) {
                        dt = new NumericType(pl);
                    }
                    else {
                        sl = Long.decode(scale.image);
                        dt = new NumericType(pl, sl);
	                }
	            }
            }
            else  if (t.kind == K_DECIMAL || t.kind == K_DEC) {
                if (precision != null && precision.image.equals("*")) {
                    precision = null;
                }
                if (precision == null) {
                    dt = new DecimalType();
                }
                else {
                    pl = Long.decode(precision.image);
                    if (scale == null) {
                        dt = new DecimalType(pl);
                    }
                    else {
                        sl = Long.decode(scale.image);
                        dt = new DecimalType(pl, sl);
                    }
                }
            }            typeStack.push(dt);         }
    | <K_LONG> [ t=<K_RAW> ] [ <O_OPENPAREN> precision=<S_NUMBER> <O_CLOSEPAREN> ]	    {
	      if (t == null) {
              if (precision == null) {
                  dt = new LongType();
              }
              else {
                  pl = Long.decode(precision.image);
                  dt = new LongType(pl);
              }
	      }
	      else {
              if (precision == null) {
                  dt = new LongRawType();
              }
              else {
                  pl = Long.decode(precision.image);
                  dt = new LongRawType(pl);
              }
            }
            typeStack.push(dt);	    }
    | <K_RAW> [ <O_OPENPAREN> precision=<S_NUMBER> <O_CLOSEPAREN> ]	    {
            if (precision == null) {
                dt = new RawType();
            }
            else {
                pl = Long.decode(precision.image);
                dt = new RawType(pl);
            }
            typeStack.push(dt);
	    }
    | <K_BOOLEAN> { typeStack.push(BOOLEAN_TYPE);}
    | <K_DATE> { typeStack.push(DATE_TYPE);}
    | LOOKAHEAD(2) <K_INTERVAL> <K_DAY> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] <K_TO> <K_SECONDS> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_INTERVAL> <K_YEAR> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] <K_TO> <K_MONTH>
    | ( <K_TIME> { typeStack.push(TIME_TYPE);}
        | <K_TIMESTAMP> { typeStack.push(TIMESTAMP_TYPE);}
      ) [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ] [ <K_WITH> [ <K_LOCAL> ] <K_TIME> <K_ZONE> ]
    | <K_INTEGER>  { typeStack.push(INTEGER_TYPE);}
    | <K_INT>      { typeStack.push(INTEGER_TYPE);}
    | <K_SMALLINT> { typeStack.push(SMALLINT_TYPE);}
    | <K_FLOAT> [ <O_OPENPAREN> precision=<S_NUMBER> <O_CLOSEPAREN> ]
        {
          if (precision == null) {
              typeStack.push(new FloatType());
          }
          else {
           pl = Long.decode(precision.image);
           FloatType ft = new FloatType(pl);
           typeStack.push(ft);          }
        }
    | <K_REAL> { typeStack.push(new RealType());}
    | <K_MLSLABEL> { typeStack.push(MLSLABEL_TYPE);}
    | <K_PLS_INTEGER> { typeStack.push(PLS_INTEGER_TYPE);}
    | <K_BLOB > { typeStack.push(new BlobType());}
    | <K_NCLOB>
    | <K_BFILE>
    | <K_ROWID> { typeStack.push(ROWID_TYPE);}
    | <K_UROWID> [ <O_OPENPAREN> precision=<S_NUMBER> <O_CLOSEPAREN> ]
        {
          if (precision == null) {
              typeStack.push(new URowIdType());
          }
          else {
              pl = Long.decode(precision.image);
              typeStack.push(new URowIdType(pl));
          }        }
    | <K_DOUBLE> <K_PRECISION> { typeStack.push(new DoubleType());}
    | <K_CHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
    | <K_VARCHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
    | <K_VARCHAR2> [ <K_VARYING> ] [ <O_OPENPAREN> t=<S_NUMBER> [ <K_BYTE> | <K_CHAR> ] <O_CLOSEPAREN> ]
        [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ]
            {
                if (t == null) {
                    typeStack.push(new VarChar2Type());
                }
                else {
                    pl = Long.decode(t.image);
                    typeStack.push(new VarChar2Type(pl));                }            }
    | <K_CHARACTER> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NCHAR> [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NVARCHAR> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NVARCHAR2> [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_NATIONAL> ( <K_CHARACTER> | <K_CHAR> ) [ <K_VARYING> ] [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    | <K_CLOB> [ LOOKAHEAD(2) <K_CHARACTER> <K_SET> [ LOOKAHEAD(2) <S_IDENTIFIER> | columnSpec() <K_CHARSET> ] ] { typeStack.push(new ClobType());}
}

String typeSpec():
{/*@bgen(jjtree) typeSpec */
 ParseNode jjtn000 = new ParseNode(JJTTYPESPEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;}
{/*@bgen(jjtree) typeSpec */
    try {
/*@egen*/
    (      datatype()
    | LOOKAHEAD(3) columnSpec() <K_TYPE2>
    | LOOKAHEAD(3) tableSpec() <K_ROWTYPE>
    | typeName() [ <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN> ]
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      Token first = jjtn000.jjtGetFirstToken();
      Token last = jjtn000.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder();
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);      }
      jjtn000.jjtSetValue(sb.toString());
      return sb.toString();    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

String columnSpec()      :
{String s1 = null;
 String s2 = null;
 String s3 = null;}
{
    s1=OracleObjectName() [ <O_DOT> s2=OracleObjectName() [ <O_DOT> s3=OracleObjectName() ] ]
    {
      StringBuilder sb = new StringBuilder(s1);
      if (s2 != null) {
          sb.append('.');
          sb.append(s2);
          if (s3 != null) {
              sb.append('.');
              sb.append(s3);
          }
      }
      return sb.toString();
    }
}

String tableSpec()      :
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() [ <O_ATSIGN> <S_IDENTIFIER> ] ]
    {return token.image;}
}

String typeName()      :
{}
{
    OracleObjectName() [ <O_DOT> OracleObjectName() ]
    {return token.image;}
}

ParseNode typeDeclaration():
{/*@bgen(jjtree) typeDeclaration */
 ParseNode jjtn000 = new ParseNode(JJTTYPEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;}
{/*@bgen(jjtree) typeDeclaration */
    try {
/*@egen*/
    <K_TYPE> s=typeName() <K_IS>
        aTypeDeclaration()
    <O_SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(s);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void aTypeDeclaration()      :
{}
{
    recordDeclaration()
    | subtypeDeclaration()
    | plsqlTableDeclaration()
    | varrayDeclaration()
    | refCursorDeclaration()
}

ParseNode recordDeclaration():
{/*@bgen(jjtree) recordDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTRECORDDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) recordDeclaration */
    try {
/*@egen*/
    <K_RECORD> <O_OPENPAREN>
        fieldDeclarations()
    <O_CLOSEPAREN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    { jjtn000.jjtSetValue("RECORD");
      return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void fieldDeclarations()      :
{}
{
    fieldDeclaration() ( <O_COMMA> fieldDeclaration() )*
}

ParseNode fieldDeclaration():
{/*@bgen(jjtree) fieldDeclaration */
 ParseNode jjtn000 = new ParseNode(JJTFIELDDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;
}
{/*@bgen(jjtree) fieldDeclaration */
    try {
/*@egen*/
    s=typeName() typeSpec() [ <K_NOT> <K_NULL> ] [ variableDefaultAssignment() ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(s);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode subtypeDeclaration():
{/*@bgen(jjtree) subtypeDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTSUBTYPEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) subtypeDeclaration */
    try {
/*@egen*/
    <K_SUBTYPE> OracleObjectName() <K_IS> datatype()
        ( <K_RANGE> <S_NUMBER> <O_DOUBLEDOT> <S_NUMBER>
        | <S_NUMBER> [ <O_COMMA> <S_NUMBER> ]
        | <K_CHARACTER> <K_SET> <S_IDENTIFIER>
        ) [ <K_NOT> <K_NULL> ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode plsqlTableDeclaration():
{/*@bgen(jjtree) plsqlTableDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTPLSQLTABLEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) plsqlTableDeclaration */
    try {
/*@egen*/
    <K_TABLE> <K_OF> typeSpec() [ <K_NOT> <K_NULL> ] <K_INDEX> <K_BY>
        plsqlTableIndexByDeclaration()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue("TABLE OF");
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode plsqlTableIndexByDeclaration():
{/*@bgen(jjtree) plsqlTableIndexByDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTPLSQLTABLEINDEXBYDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) plsqlTableIndexByDeclaration */
    try {
/*@egen*/
    ( <K_PLS_INTEGER >
    | <K_BINARY_INTEGER>
    | <K_VARCHAR2> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
    | <K_STRING> <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      Token first = jjtn000.jjtGetFirstToken();
      Token last = jjtn000.jjtGetLastToken();
      Token cur = first;
      StringBuilder sb = new StringBuilder("INDEX BY ");
      sb.append(first.image);
      while (cur != last) {
          cur = cur.next;
          sb.append(cur.image);
      }
      jjtn000.jjtSetValue(sb.toString());
      return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode varrayDeclaration():
{/*@bgen(jjtree) varrayDeclaration */
  ParseNode jjtn000 = new ParseNode(JJTVARRAYDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) varrayDeclaration */
    try {
/*@egen*/
    ( <K_VARRAY> | <K_VARYING> <K_ARRAY> ) <O_OPENPAREN> <S_NUMBER> <O_CLOSEPAREN>
        <K_OF> datatype() [ <K_NOT> <K_NULL> ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode refCursorDeclaration():
{/*@bgen(jjtree) refCursorDeclaration */
 ParseNode jjtn000 = new ParseNode(JJTREFCURSORDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;}
{/*@bgen(jjtree) refCursorDeclaration */
    try {
/*@egen*/
    <K_REF> <K_CURSOR> [ refCursorTypeSpec() ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue("REF CURSOR");
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode refCursorTypeSpec():
{/*@bgen(jjtree) refCursorTypeSpec */
 ParseNode jjtn000 = new ParseNode(JJTREFCURSORTYPESPEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/String s = null;}
{/*@bgen(jjtree) refCursorTypeSpec */
    try {
/*@egen*/
    <K_RETURN> [LOOKAHEAD(3) s=columnSpec() [ <K_TYPE2> ]
    | LOOKAHEAD(3) s=tableSpec() [ <K_ROWTYPE> ] ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue("RETURN " +s);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode cursorDeclaration():
{/*@bgen(jjtree) cursorDeclaration */
 ParseNode jjtn000 = new ParseNode(JJTCURSORDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t = null;}
{/*@bgen(jjtree) cursorDeclaration */
    try {
/*@egen*/
    <K_CURSOR> t=<S_IDENTIFIER>
    <O_SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

// Procedure Specification
ParseNode procedureSpec():
{/*@bgen(jjtree) procedureSpec */
 ParseNode jjtn000 = new ParseNode(JJTPROCEDURESPEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t = null;}
{/*@bgen(jjtree) procedureSpec */
    try {
/*@egen*/
    <K_PROCEDURE> t=<S_IDENTIFIER>
        [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ]
    <O_SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue("PROCEDURE " + t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void argumentList()      :
{}
{
   argument() ( <O_COMMA> argument() )*
}

// Function Specification
ParseNode functionSpec():
{/*@bgen(jjtree) functionSpec */
 ParseNode jjtn000 = new ParseNode(JJTFUNCTIONSPEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t = null;}
{/*@bgen(jjtree) functionSpec */
    try {
/*@egen*/
    <K_FUNCTION> t=<S_IDENTIFIER>
        [ <O_OPENPAREN> argumentList() <O_CLOSEPAREN> ]
        functionReturnSpec()
        [ <K_DETERMINISTIC> | <K_PIPELINED> | <K_PARALLEL_ENABLE> | <K_RESULT_CACHE> ]
    <O_SEMICOLON>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue("FUNCTION " + t.image);
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode functionReturnSpec():
{/*@bgen(jjtree) functionReturnSpec */
  ParseNode jjtn000 = new ParseNode(JJTFUNCTIONRETURNSPEC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}{/*@bgen(jjtree) functionReturnSpec */
    try {
/*@egen*/    (<K_RETURN> typeSpec())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue("RETURN");
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

ParseNode argument():
{/*@bgen(jjtree) argument */
 ParseNode jjtn000 = new ParseNode(JJTARGUMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t = null;
 String direction = null;
}
{/*@bgen(jjtree) argument */
    try {
/*@egen*/
    t=<S_IDENTIFIER> [(direction=direction())]
        [ <K_NOCOPY> ] typeSpec() [ argumentDefaultAssignment() ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      if (direction != null) {
          jjtn000.jjtSetValue(direction + " " + t.image);
      }
      else {
          // by default, arguments are IN
          jjtn000.jjtSetValue("IN " + t.image);
      }
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

String direction()      :
{}
{
    LOOKAHEAD(2) <K_IN> <K_OUT> { return "IN OUT"; }
    | <K_IN> { return "IN"; }
    | <K_OUT>  { return "OUT"; }
}

ParseNode argumentDefaultAssignment():
{/*@bgen(jjtree) argumentDefaultAssignment */
  ParseNode jjtn000 = new ParseNode(JJTARGUMENTDEFAULTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) argumentDefaultAssignment */
    try {
/*@egen*/
    ( <O_ASSIGN> | <K_DEFAULT> ) skipToNextArg()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.jjtSetLastToken(getToken(0));
    }
/*@egen*/
    {
      jjtn000.jjtSetValue(" (optional)");
      return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void exceptionDeclaration()      :
{}
{
    <S_IDENTIFIER> <K_EXCEPTION>
    <O_SEMICOLON>
}

void pragmaDeclaration()      :
{}
{    <K_PRAGMA>
    [ <K_AUTONOMOUS_TRANSACTION>
    | <K_EXCEPTION_INIT> <O_OPENPAREN> <S_IDENTIFIER> <O_COMMA> <S_NUMBER> <O_CLOSEPAREN>
    | <K_SERIALLY_REUSABLE>
    | <K_INLINE> <O_OPENPAREN> <S_IDENTIFIER> <O_COMMA> [ <K_YES> | <K_NO> ] <O_CLOSEPAREN>
    | <K_RESTRICT_REFERENCES> <O_OPENPAREN> [ <S_IDENTIFIER> | <K_DEFAULT> ]
        ( <O_COMMA> [ <K_RNDS> | <K_WNDS> | <K_RNPS> | <K_WNPS> | <K_TRUST>] )+ <O_CLOSEPAREN>
    ]
    <O_SEMICOLON>
}

String OracleObjectName()      :
{}
{
    <S_IDENTIFIER>
    {return token.image;}
  | <S_QUOTED_IDENTIFIER>
    {
      String s = token.image;
      return s.substring(1, s.length() - 1); // strip-off quotes
    }
}

void skipToSemiColon()      :
{}
{
    {
        Token t = getNextToken();
        while (t.kind != O_SEMICOLON) {
	        t = getNextToken();
        }
        token_source.input_stream.backup(1);
    }
}

void skipToNextArg()      :
{}
{
    {
        Token t = getNextToken();
        while (t.kind != O_COMMA && t.kind != O_CLOSEPAREN) {
            t = getNextToken();
        }
        token_source.input_stream.backup(1);
    }
}

void skipToEnd()      :
{}
{
    {
      /** skip through all the tokens. */
      Token t = getNextToken();
      while (t.kind != EOF) {
          t = getNextToken();
      }
  }

}